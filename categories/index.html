<!DOCTYPE html>
<html>
  <head>
    <title>Categories</title>
    <meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<meta http-equiv="X-UA-Compatible" content="ie=edge" />


<link rel="stylesheet" href="/assets/css/bootstrap.min.css" />
<link rel="stylesheet" href="/assets/css/style.css" />
<link rel="stylesheet" href="/assets/css/navbar.css" />


<link href="https://fonts.googleapis.com/css?family=Muli" rel="stylesheet" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/all.min.css" />


<link rel="icon" type="image/png" href="/assets/images/favicon.png" />


    
    <link rel="stylesheet" href="/assets/css/list.css">


    
    
      
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', '\u003cyour google analytics id\u003e', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>

    
  </head>

  <body>
    <div class="container-fluid bg-dimmed wrapper">
      
      
    <nav class="navbar navbar-expand-lg top-navbar final-navbar shadow">
    <div class="container">
      <a class="navbar-brand" href="http://example.org/">
        <img src="/assets/images/logo.png">CC&#39;s Trip</a>
      <button class="navbar-toggler navbar-light" type="button" onclick="toggleSidebar()">
        <span class="navbar-toggler-icon"></span>
      </button>

      <div class="collapse navbar-collapse" id="top-nav-items">
        <ul class="navbar-nav ml-auto">
        </ul>
        </ul>
      </div>
    </div>
</nav>



      
      
<div class="sidebar" id="sidebar">
    <div class="sidebar-tree">
      <input type="text" name="filtr-search" value="" placeholder="Search" data-search="" id="search-box" />
      <ul class="tree" id="tree">
        <li id="list-heading"><a href="#" data-filter="all">Categories</a></li>
        <div class="subtree">
            

        </div>
      </ul>
    </div>
  </div>
  <div class="content container-fluid" id="content">
    <div class="content-cards">
      <div class="container-fluid filtr-container post-cards" id="post-cards">
        
          <div class="filtr-item" data-category='technology,linux'>
  <a href="/posts/nginx_match/" class="post-card-link">
    <div class="card">
      <div class="card-head">
        <img class="card-img-top" src='/images/posts/nginx.png'/>
      </div>
      <div class="card-body">
        <h5 class="card-title">Nginx匹配机制总结</h5>
        <p class="card-text post-summery">写在前面 Nginx是一个当前主流的HTTP服务器和反向代理服务器，很多做WEB相关的同学基本都会用到，很多云厂商的七层负载均衡器也基本都是基于nginx实现的，个人在工作过程也算是经常接触，这篇文章主要想总结一下nginx的匹配机制，主要分为两块，一块是server的匹配，一块是location的匹配。
 Server匹配机制 配置过nginx的都知道，在一个http模块中是可以配置多个server模块的，并且多个server模块是可以配置相同的监听端口的，下面是一个简单的server配置例子：
server { listen 80; server_name example.org www.example.org; ... } server { listen 80; server_name example.net www.example.net; ... } server { listen 80; server_name example.com www.example.com; ... } 当我们对nginx发起http请求后，nginx会拿到http请求中对应的 &quot;Host&quot; 头部跟server模块中的server_name进行匹配，根据匹配的server结果进入具体的server模块处理http请求。那么，它具体的匹配机制是怎样的呢？
首先，我们先简单了解下nginx内部server的相关结构，
其中listen和server_name在配置文件中的写法有：
 listen(可带default_server标识)  ip:port ip(监听80端口) port(监听所有地址)   server_name  www.example.com(完整域名) *.example.com(带通配符开头的域名) www.example.*(带通配符结尾的域名) ~^(www.)?(.+)$(正则写法的域名)    代码中的具体结构：
/************************************************************************************* 伪结构体示例 (port) --&gt; address(ip:port) --&gt; server(example.com) --&gt; server(example.net) 一个server模块的唯一标识是由address(listen配置)和server(server_name配置)组成 *************************************************************************************/ /* address 结构体，具有相同的ip:port */ struct ngx_http_addr_conf_s { /* default_server 存储的是listen配置里带default_server标识的server， 若没有就为顺序中的第一个server */ ngx_http_core_srv_conf_t *default_server; ngx_http_virtual_names_t *virtual_names; unsigned ssl:1; unsigned http2:1; unsigned proxy_protocol:1; }; /* virtual_name结构体，存储hash_combined和正则写法的server_name */ typedef struct { ngx_hash_combined_t names; ngx_uint_t nregex; ngx_http_server_name_t *regex; } ngx_http_virtual_names_t; /* hash_combined结构体，存储完成域名、通配符开头、通配符结尾的server_name */ typedef struct { ngx_hash_t hash; ngx_hash_wildcard_t *wc_head; ngx_hash_wildcard_t *wc_tail; } ngx_hash_combined_t; 通过结构体，我们来说明下server的匹配规则：</p>
      </div>
      <div class="card-footer">
        <span class="float-left">June 6, 2020</span>
        <a
        href="/posts/nginx_match/"
        class="float-right btn btn-outline-info btn-sm"
        >Read</a
        >
      </div>
    </div>
  </a>
</div>

        
          <div class="filtr-item" data-category='technology,linux'>
  <a href="/posts/linux_pam/" class="post-card-link">
    <div class="card">
      <div class="card-head">
        <img class="card-img-top" src='/images/posts/linux.jpg'/>
      </div>
      <div class="card-body">
        <h5 class="card-title">Linux pam模块</h5>
        <p class="card-text post-summery">概念 Linux-PAM（Pluggable Authentication Modules for Linux）是一套共享库,使本地系统管理员可以随意选择程序的认证方式。换句话说，不用(重新编写)重新编译一个包含PAM功能的应用程序，就可以改变它使用的认证机制，这种方式下，就算升级本地认证机制,也不用修改程序。
 工作机制 当应用程序希望与PAM交互以处理事件时，他们必须包括libpam，该libpam允许通过库提供的API进行通信。 当PAM看到必须处理的新事件时，它将查看/etc/pam.d中的相关配置文件，并确定在某些阶段必须使用哪些模块。
 /etc/pam.d配置文件介绍 配置文件语法
type control module-path module-arguments 配置文件分为四列
 第一列代表模块类型 第二列代表控制标记 第三列代表模块路径 第四列代表模块参数  类型 类型 是规则对应的管理组。它用于指定后续模块要与哪个管理组关联。
目前有四种类型:
  account
此模块类型执行基于非身份验证的帐户管理。 通常用于限制/允许对服务的访问，例如是否允许登录,是否达到最大用户数,或是root用户是否允许在这个终端登录等。
  auth
此模块为用户验证提供两方面服务。让应用程序提示用户输入密码或者其他标记，确认用户合法性；通过他的凭证许可权限，设定组成员关系或者其他优先权。
  password
此模块用于控制用户更改密码的全过程。
  session
此模块处理为用户提供服务之前/后需要做的些事情。包括：开启/关闭交换数据的信息，监视目录等，设置用户会话环境等。也就是说这是在系统正式进行服务提供之前的最后一道关口。
  如果在类型前加一个短横线 -，就表示如果找不到这个模块，导致无法被加载时，这一事件不会被记录在日志中。这个功能适用于那些认证时非必需的、安装时可能没被安装进系统的模块。
控制标记 流程栈（stack）
它是认证时执行步骤和规则的堆叠。在某个服务的配置文件中，它体现在了配置文件中的自上而下的执行顺序中。栈是可以被引用的，即在一个栈（或者流程）中嵌入另一个栈。
控制标记 规定如何处理PAM模块鉴别认证的结果，简而言之就是鉴别认证成功或者失败之后会发生什么事，如何进行控制。一般有两种形式，一种是比较常见的“关键字”方式，另一种则是用方括号（[]）包含的“value =action”方式。
关键字方式:   required
如果本条目没有被满足，那最终本次认证一定失败，但认证过程不因此打断。整个栈运行完毕之后才会返回“认证失败”信号。
  requisite
如果本条目没有被满足，那本次认证一定失败，而且整个栈立即中止并返回错误信号。
  sufficient
  如果本条目的条件被满足，且本条目之前没有任何required条目失败，则立即返回“认证成功”信号；如果对本条目的验证失败，不对结果造成影响。</p>
      </div>
      <div class="card-footer">
        <span class="float-left">April 5, 2020</span>
        <a
        href="/posts/linux_pam/"
        class="float-right btn btn-outline-info btn-sm"
        >Read</a
        >
      </div>
    </div>
  </a>
</div>

        
          <div class="filtr-item" data-category='technology,linux'>
  <a href="/posts/file_descriptor/" class="post-card-link">
    <div class="card">
      <div class="card-head">
        <img class="card-img-top" src='/images/posts/linux.jpg'/>
      </div>
      <div class="card-body">
        <h5 class="card-title">谈谈文件描述符</h5>
        <p class="card-text post-summery">概念 wiki解释，文件描述符在形式上是一个非负整数。实际上，它是一个索引值，指向内核为每一个进程所维护的该进程打开文件的记录表。当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。在程序设计中，一些涉及底层的程序编写往往会围绕着文件描述符展开。
一个文件描述符是一个数字，唯一标识一个在计算机的操作系统打开的文件。它描述了数据资源，以及如何访问该资源。
当程序要求打开文件（或其他数据资源，例如网络套接字）时，内核：
 授予访问权限。 在全局文件表中创建一个条目。 向软件提供该条目的位置。  该描述符是唯一的非负整数。系统上每个打开的文件至少存在一个文件描述符。
 细节 对于内核，所有打开的文件均由文件描述符引用。文件描述符是一个非负数。当我们打开现有文件或创建新文件时，内核将文件描述符返回到进程。当我们想读取或写入文件时，我们用文件描述符标识文件。
每个Linux进程（也许是守护程序除外）都应该具有三个标准的POSIX文件描述符：
   POSIX常数名称 文件描述符 描述     STDIN_FILENO 0 标准输入   STDOUT_FILENO 1 标准输出   STDERR_FILENO 2 标准误差    有三个“系统文件表”：有一个文件描述符表，它将文件描述符（小整数）映射到打开的文件表中的条目。打开文件表中的每个条目（除其他事项外）还包含文件偏移量和指向内存中inode表的指针。在打开的文件表中，每个open（）调用都有一个文件表条目，如果文件描述符是dup（）ed或fork（）ed，则共享该条目。
我们使用来自维基百科的示例来显示这些表的工作方式。这是一张照片： 单个进程的文件描述符，文件表和索引节点表。请注意，多个文件描述符可以引用相同的文件表条目（例如，由于dup系统调用），并且多个文件表条目可以依次引用同一个索引节点（如果已多次打开；则该表之所以仍然简化，是因为它通过文件名来表示索引节点，即使索引节点可以具有多个名称也是如此。文件描述符3没有引用文件表中的任何内容，表明它已关闭。
理解具体情况，需要了解由内核维护的 3 个数据结构：
 进程级 文件描述符表 ( file descriptor table ) 系统级 打开文件表 ( open file table ) 文件系统 i-node表 ( i-node table )  这 3 个数据结构之间的关系如 图-1 所示：</p>
      </div>
      <div class="card-footer">
        <span class="float-left">March 29, 2020</span>
        <a
        href="/posts/file_descriptor/"
        class="float-right btn btn-outline-info btn-sm"
        >Read</a
        >
      </div>
    </div>
  </a>
</div>

        
          <div class="filtr-item" data-category='technology,security,network'>
  <a href="/posts/tls/" class="post-card-link">
    <div class="card">
      <div class="card-head">
        <img class="card-img-top" src='/images/posts/security.jpg'/>
      </div>
      <div class="card-body">
        <h5 class="card-title">理解SSL/TLS协议</h5>
        <p class="card-text post-summery">背景 早期我们在访问web时使用HTTP协议，该协议在传输数据时使用明文传输，明文传输带来了以下风险：
 信息窃听风险，第三方可以获取通信内容 信息篡改风险，第三方可以篡改通信内容 身份冒充风险，第三方可以冒充他人身份参与通信  为了解决明文传输所带来的风险，网景公司在1994年设计了SSL用于Web的安全传输协议，这是SSL的起源。IETF将SSL进行标准化，1999年公布了第一版TLS标准文件。随后又公布了 RFC 5246（2008年8月）与 RFC 6176 （2011年3月）。该协议在web中被广泛应用。
 SSL/TLS协议 TLS（Transport Layer Security，传输层安全协议），及其前身SSL（Secure Sockets Layer，安全套接层）是一种安全协议，目的是为互联网通信，提供安全及数据完整性保障。
TLS协议使用以下三种机制为信息通信提供安全传输：
 隐秘性，所有通信都通过加密后进行传播 身份认证，通过证书进行认证 可靠性，通过校验数据完整性维护一个可靠的安全连接   工作机制 TLS协议由两部分组成，包括（TLS Record Layer,TLS handshake protocol）
  Record Layer：
为每条信息提供一个header和在尾部生成一个从Message Authentication Code (MAC) 得到的hash值，其中header由5 bytes组成，分别是协议说明(1bytes),协议版本(2bytes)和长度(2bytes)，跟在header后面的协议信息长度不得超过16384bytes。　  Handshake Protocol：
开始一个安全连接需要客户端和服务端经过反复的建立握手。一个TLS握手需要经过如下几个步骤：
  首先还是要经过TCP三次握手建立连接，然后才是TLS握手的开始：
  ClientHello：Client端将自己的TLS协议版本，加密套件，压缩方法，随机数，SessionID(未填充)发送给Server端
  ServerHello：Server端将选择后的SSL协议版本，压缩算法，密码套件，填充SessionID，生成的随机数等信息发送给Client端
  ServerCertificates：Server端将自己的数字证书(包含公钥)，发送给Client端。(证书需要从数字证书认证机构(CA)申请，证书是对于服务端的一种认证)，若要进行更为安全的数据通信，Server端还可以向Client端发送Cerficate Request来要去客户端发送对方的证书进行合法性的认证。
  ServerHelloDone：当完成ServerHello后，Server端会发送Server Hello Done的消息给客户端，表示ServerHello 结束了。
  ClientKeyExchage：当Client端收到Server端的证书等信息后，会先对服务端的证书进行检查，检查证书的完整性以及证书跟服务端域名是否吻合，然后使用加密算法生成一个PreMaster Secret，并通过Server端的公钥进行加密，然后发送给Server端。</p>
      </div>
      <div class="card-footer">
        <span class="float-left">January 8, 2017</span>
        <a
        href="/posts/tls/"
        class="float-right btn btn-outline-info btn-sm"
        >Read</a
        >
      </div>
    </div>
  </a>
</div>

        
          <div class="filtr-item" data-category='technology,network'>
  <a href="/posts/http/" class="post-card-link">
    <div class="card">
      <div class="card-head">
        <img class="card-img-top" src='/images/posts/network.jpg'/>
      </div>
      <div class="card-body">
        <h5 class="card-title">谈谈HTTP</h5>
        <p class="card-text post-summery">写在前面 如今网络已经无处不在，人们通过网络获取浏览各种信息，其中，大部分都是通过浏览器访问各种网页来获取我们想要的信息，那么浏览器与网页(服务端)究竟是如何通信的呢？这就得从HTTP协议说起了，浏览器获取网页信息都是基于HTTP协议来处理的。
 概念 HTTP（HyperText Transfer Protocol，超文本传输协议）是互联网上应用最为广泛的一种网络协议。设计HTTP最初的目的是为了提供一种发布和接收HTML页面的方法。通过HTTP或者HTTPS协议请求的资源由统一资源标识符（Uniform Resource Identifiers，URI）来标识。HTTP是一个应用层协议，由请求和响应构成，是一个标准的客户端服务器模型。其具有如下特点：
  支持客户/服务器模式。
  简单快速：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有GET、HEAD、POST。每种方法规定了客户与服务器联系的类型不同。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。
  灵活：HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记。
  无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。
  无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快
  PS：尽管TCP/IP协议是互联网上最流行的应用，HTTP协议中，并没有规定必须使用它或它支持的层。事实上，HTTP可以在任何互联网协议上，或其他网络上实现。HTTP假定其下层协议提供可靠的传输。因此，任何能够提供这种保证的协议都可以被其使用。因此也就是其在TCP/IP协议族使用TCP作为其传输层。
 工作流程 HTTP协议的通信过程永远是客户端发起请求(request)，服务器回送响应(respone)，如下图所示：
一个完整的HTTP操作称为一个事务，其流程可分为四步：
  建立连接(TCP三次握手)
  客户端发送一个请求报文给服务器
  服务器响应对应信息
  客户端接收信息，然后断开连接
   请求和响应详解 请求报文   请求行：由请求方法、URL和HTTP版本组成
eg：GET /index.html HTTP/1.1
  请求方法
  GET：请求获取URI所标识的资源
  HEAD：请求获取URI所标识的资源，但不传回资源的文本部分
  POST：向指定URI资源提交数据，请求服务器进行处理
  PUT：向指定URI资源上传其最新内容
  DELETE：请求服务器删除URI所标识的资源</p>
      </div>
      <div class="card-footer">
        <span class="float-left">May 29, 2016</span>
        <a
        href="/posts/http/"
        class="float-right btn btn-outline-info btn-sm"
        >Read</a
        >
      </div>
    </div>
  </a>
</div>

        
          <div class="filtr-item" data-category='technology,linux'>
  <a href="/posts/systemstart/" class="post-card-link">
    <div class="card">
      <div class="card-head">
        <img class="card-img-top" src='/images/posts/linux.jpg'/>
      </div>
      <div class="card-body">
        <h5 class="card-title">理解系统启动过程</h5>
        <p class="card-text post-summery">前言 Linux是一种自由和开放源代码的类UNIX操作系统。该操作系统的内核由林纳斯·托瓦兹在1991年10月5日首次发布。在加上用户空间的应用程序之后，成为Linux操作系统。Linux是自由软件和开放源代码软件发展中最著名的例子。
接触Linux的时间也不算短了，一直都是直接使用Linux操作系统进行一些工作，很少去了解系统从开机到能使用的整个过程，感觉有需要好好理解下整个系统的启动过程，故写这篇博客加深一下理解。
 启动过程 先通过一张图来简单了解下整个系统启动的流程，整个过程基本可以分为POST&ndash;&gt;BIOS&ndash;&gt;MBR(GRUB)&ndash;&gt;Kernel&ndash;&gt;Init&ndash;&gt;Runlevel。下面会详细说明每个过程的作用。
  BIOS
BIOS(Basic Input/Output System)，基本输入输出系统，该系统存储于主板的ROM芯片上，计算机在开机时，会最先读取该系统，然后会有一个加电自检过程，这个过程其实就是检查CPU和内存，计算机最基本的组成单元(控制器、运算器和存储器)，还会检查其他硬件，若没有异常就开始加载BIOS程序到内存当中。详细的BIOS功能，这边就不说了，BIOS主要的一个功能就是存储了磁盘的启动顺序，BIOS会按照启动顺序去查找第一个磁盘头的MBR信息，并加载和执行MBR中的Bootloader程序，若第一个磁盘不存在MBR，则会继续查找第二个磁盘(PS：启动顺序可以在BIOS的界面中进行设置)，一旦BootLoader程序被检测并加载内存中，BIOS就将控制权交接给了BootLoader程序。
  MBR
MBR(Master Boot Record)，主引导记录，MBR存储于磁盘的头部，大小为512bytes，其中，446bytes用于存储BootLoader程序，64bytes用于存储分区表信息，最后2bytes用于MBR的有效性检查。
  GRUB
GRUB(Grand Unified Bootloader)，多系统启动程序，其执行过程可分为三个步骤：
  Stage1：这个其实就是MBR，它的主要工作就是查找并加载第二段Bootloader程序(stage2)，但系统在没启动时，MBR根本找不到文件系统，也就找不到stage2所存放的位置，因此，就有了stage1_5
  Stage1_5：该步骤就是为了识别文件系统
  Stage2：GRUB程序会根据/boot/grub/grub.conf文件查找Kernel的信息，然后开始加载Kernel程序，当Kernel程序被检测并在加载到内存中，GRUB就将控制权交接给了Kernel程序。
PS：实际上这个步骤/boot还没被挂载，GRUB直接识别grub所在磁盘的文件系统，所以实际上应该是/grub/grub.conf文件，该配置文件的信息如下：
grub.conf:
     #boot=/dev/sda
default=0 #设定默认启动的title的编号，从0开始
timeout=5 #等待用户选择的超时时间
splashimage=(hd0,0)/boot/grub/splash.xpm.gz #GRUB的背景图片
hiddenmenu #隐藏菜单
title CentOS (2.6.18-194.el5PAE) #内核标题
root (hd0,0) #内核文件所在的设备 kernel /vmlinuz-2.6.18-194.el5PAE ro root=LABEL=/ #内核文件路径以及传递给内核的参数 initrd /initrd-2.6.18-194.el5PAE.img #ramdisk文件路径 ```    Kernel
Kernel，内核，Kernel是Linux系统最主要的程序，实际上，Kernel的文件很小，只保留了最基本的模块，并以压缩的文件形式存储在硬盘中，当GRUB将Kernel读进内存，内存开始解压缩内核文件。讲内核启动，应该先讲下initrd这个文件，</p>
      </div>
      <div class="card-footer">
        <span class="float-left">May 21, 2016</span>
        <a
        href="/posts/systemstart/"
        class="float-right btn btn-outline-info btn-sm"
        >Read</a
        >
      </div>
    </div>
  </a>
</div>

        
          <div class="filtr-item" data-category='technology,network'>
  <a href="/posts/dns/" class="post-card-link">
    <div class="card">
      <div class="card-head">
        <img class="card-img-top" src='/images/posts/network.jpg'/>
      </div>
      <div class="card-body">
        <h5 class="card-title">谈谈DNS</h5>
        <p class="card-text post-summery">写在前面 目前，我们大部分的网络通信都是基于TCP/IP协议的，而TCP/IP又基于IP地址作为唯一标识进行通信，随着需要记忆的IP地址数量的增多，肯定会超出我们的记忆能力范围，但如果使用一种利于人们的记忆的方式，如域名，例如&quot;www.google.com&rdquo;，我们便可以轻松的记忆这种方式的标识，而不是繁杂的数字。而DNS(域名系统)就是为了可以使用这种方式提供服务的。
 概念 DNS(Domain Name System)，域名系统，它是因特网的一项服务。它作为将域名和IP地址相互映射的一个分布式数据库，能够使人更方便地访问互联网。DNS使用TCP和UDP端口53。当前，对于每一级域名长度的限制是63个字符，域名总长度则不能超过253个字符。
DNS Domain Namespace，DNS域命名空间，是一种分层树状结构，其格式如下:&ldquo;www.google.com&rdquo;,以点&rdquo;.&ldquo;为分隔。结构如图所示：
  根域：绝对域名(FQDN)，以点&rdquo;.&ldquo;结尾的域名
  顶级域：用来指示某个国家/地区或组织使用的名称的类型名称，例如.com
  二级域：个人或组织在因特网上使用的注册名称，例如google.com
  子域：已注册的二级域名派生的域名，一般就是网站名，例如www.google.com
  主机名：标识网络上的特定计算机，例如h1.www.google.com
  DNS资源记录：(即映射关系，通常由域名管理员进行配置)，常见类型如下：
  SOA：起始授权机构
  NS：名称服务器
  MX：邮件服务器
  A：IP地址(最常用，映射IP地址)
  CNAME：别名(较常用，映射到其他域名)
   DNS工作原理 当我们请求一个域名时，会通过DNS服务器将域名解析成IP访问最终的主机，那么，DNS是如何查询到域名所对应的IP并返回给我们的呢？请工作机制如图所示：
当我们请求一个域名时，直到获取到IP地址，整个过程是如何工作的？以请求www.codecc.xyz为例：
  首先，我们的主机会去查找本地的hosts文件和本地DNS解析器缓存，如果hosts文件和本地DNS缓存存在www.codecc.xyz和IP的映射关系，则完成域名解析，请求该IP地址，否则进入第二步。
  当hosts和本地DNS解析器缓存都没有对应的网址映射关系，则会根据机器(/etc/reslove.conf)配置的本地DNS服务器进行查询，此服务器收到查询时，如果要查询的域名在本地配置区域资源或者缓存中存在映射关系，则跳到步骤9，将解析结果直接返回给客户机。
  PS：一二步骤为递归查询，其余步骤为迭代查询
 若本地DNS服务器不存在该域名的映射关系，就把请求发送至13台根DNS服务器。
  根DNS服务器会判断这个域名(.xyz)由谁来授权管理，并返回一个负责该顶级域的DNS服务器的一个IP给本地DNS服务器。
  本地DNS服务器收到该IP后，会再将查询请求发送至(.xyz)所在的DNS服务器。
  如果(.xyz)的DNS服务器无法解析该域名，就会去判断这个二级域名(codecc.xyz)的管理者，返回一个负责该二级域的DNS服务器的IP给本地DNS服务器。
  本地DNS服务器收到该IP后，会再次将查询请求发送至(codecc.</p>
      </div>
      <div class="card-footer">
        <span class="float-left">May 21, 2016</span>
        <a
        href="/posts/dns/"
        class="float-right btn btn-outline-info btn-sm"
        >Read</a
        >
      </div>
    </div>
  </a>
</div>

        
          <div class="filtr-item" data-category='technology,security,network'>
  <a href="/posts/webcsp/" class="post-card-link">
    <div class="card">
      <div class="card-head">
        <img class="card-img-top" src='/images/posts/security.jpg'/>
      </div>
      <div class="card-body">
        <h5 class="card-title">WEB安全之CSP</h5>
        <p class="card-text post-summery">概念 内容安全策略(Content-Security-Policy，CSP)：是一种web应用技术用于帮助缓解大部分类型的内容注入攻击，包括XSS攻击和数据注入等，这些攻击可实现数据窃取、网站破坏和作为恶意软件分发版本等行为。该策略可让网站管理员指定客户端允许加载的各类可信任资源。
 浏览器支持 统计来源：caniuse.com/contentsecuritypolicy &amp; Mozilla
 指令参考 Content-Security-Policy 响应头的值可配置一个或多个，多个指令以分号;隔开。
   指令 示例 描述     default-src &lsquo;self&rsquo; cdn.example.com 默认配置，若其他指令没有配置，都以此配置的规则为准   script-src &lsquo;self&rsquo; js.example.com 定义允许加载的JavaScript来源   style-src &lsquo;self&rsquo; css.example.com 定义允许加载的样式表来源   img-src &lsquo;self&rsquo; img.example.com 定义允许加载的图片来源   connect-src &lsquo;self&rsquo; 适用于XMLHttpRequest(AJAX),WebSocket或EventSource，当为不允许的来源，浏览器返回一个400的状态码。   font-src font.example.com 定义允许加载的字体来源   object-src &lsquo;self&rsquo; 定义允许加载的插件来源.eg,&lt;object&gt;,&lt;embed&gt;或&lt;applet&gt;   media-src media.example.com 定义允许加载的audio和video.eg,HTML5,&lt;audio&gt;,&lt;video&gt;元素   frame-src &lsquo;self&rsquo; 定义允许加载的框架来源   sandbox allow-forms allow-scripts 授权一个沙箱用来请求具有iframe sanbox等类似属性的资源,该沙箱默认为同源策略,禁止弹出窗口,执行插件和脚本.</p>
      </div>
      <div class="card-footer">
        <span class="float-left">May 20, 2016</span>
        <a
        href="/posts/webcsp/"
        class="float-right btn btn-outline-info btn-sm"
        >Read</a
        >
      </div>
    </div>
  </a>
</div>

        
          <div class="filtr-item" data-category='technology,network'>
  <a href="/posts/networkcomm/" class="post-card-link">
    <div class="card">
      <div class="card-head">
        <img class="card-img-top" src='/images/posts/network.jpg'/>
      </div>
      <div class="card-body">
        <h5 class="card-title">简单理解计算机通信</h5>
        <p class="card-text post-summery">写在前面： 在计算机刚出现的时候，只能在本机进行一些运算处理，想将一台计算机中的数据转移到另一台计算机中，需要通过外部存储介质来传输，例如磁带、软盘。而网络技术的出现，使得计算机间可以通过一些传输介质(网线、光纤等)，实现快速的数据传输和信息交互。如今，网络已无处不在，那么，计算机之间究竟是如何通信的呢？下面会通过一些基础的网络知识来简单理解计算机之间的通信过程。
 网络通信模型： 网络通信模型是一种概念模型和框架，旨在使各种计算机在世界范围内互连为网络。其中有OSI七层模型和TCP/IP四层模型，现在大部分网络通信都是以TCP/IP四层模型为基础的。它们的对应层次如下图：
  OSI有七层：从上到下依次为应用层、表示层、会话层、传输层、网络层、数据链路层、物理层
  TCP/IP有四层：从上到下依次为应用层、传输层、互连层(网络层)、网络接口层(链路层)。
  因为目前大部分TCP/IP模型，所以就以TCP/IP为例，我们来理解下数据间的通信，下图是两台计算机通信的数据的传输过程：
 数据封装： 在详细了解TCP/IP每一层各自的作用前，先要理解数据封装的概念，数据在通过网络接口传送出去前，会经过层层封装，每层都会在前面的基础上添加自己的信息，在传输到对方计算机后，又会被层层进行解封装后得到最后的数据。其过程如下图所示：
 TCP/IP参考模型： TCP/IP参考模型是一个抽象的分层模型，这个模型中，所有的TCP/IP系列网络协议都被归类到4个抽象的&quot;层&quot;中。每一抽象层创建在低一层提供的服务上，并且为高一层提供服务。 完成一些特定的任务需要众多的协议协同工作，这些协议分布在参考模型的不同层中的，因此有时称它们为一个协议栈。
应用层(Application Layer)：  该层包括所有和应用程序协同工作，利用基础网络交换应用程序专用的数据的协议。 应用层是大多数普通与网络相关的程序为了通过网络与其他程序通信所使用的层。这个层的处理过程是应用特有的；数据从网络相关的程序以这种应用内部使用的格式进行传送，然后被编码成标准协议的格式。 常见的应用层协议有HTTP、FTP、DNS、SNMP(基于UDP)  传输层(Transport Layer)：  主要为两台主机上的应用程序提供端到端的通信，包括TCP协议（传输控制协议）和UDP（用户数据报协议）。 端口号由此层提供，且在一台计算机中具有唯一性。 UDP为应用层提供一种非常简单的服务。它只是把称作数据报的分组从一台主机发送到另一台主机，但并不保证该数据报能到达另一端。任何必需的可靠性必须由应用层来提供。 TCP为两台主机提供高可靠性的数据通信。它所做的工作包括把应用程序交给它的数据分成合适的小块交给下面的网络层，确认接收到的分组，设置发送最后确认分组的超时时钟等,由于运输层提供了高可靠性的端到端的通信，因此应用层可以忽略所有这些细节。 因为TCP是一种面向连接的协议，所以两个在使用TCP的应用在彼此交换数据前必须先建立一个TCP连接，也就是有名的TCP三次握手，如下图所示：  建立连接协议过程：（TCP三次握手协议）
 客户端发送一个SYN段指明客户打算连接的服务器的端口，以及初始序号（ISN）。 服务器发回包含服务器的初始序号的SYN报文段作为应答。同时，将确认序号设置为客户的ISN加1以对客户的SYN报文段进行确认。一个SYN占用一个序号。 客户将确认序号设置为服务器的ISN加1以对服务器的SYN报文段进行确认。  网络层(Internet Layer)：   处理分组在网络中的活动。网络层协议包括IP协议（网际协议），ICPM协议（Internet互联网控制报文协议），以及IGMP协议（Internet组管理协议），其中的IP协议身是TCP/IP协议簇中最为核心的协议。IP提供的是不可靠、无连接的数据包传送服务。
  IP地址：
   讲到IP协议就应该讲讲IP地址，IP地址是分配给网络上使用IP协议的设备的数字标签，有IPv4和IPv6两大类，我们目前使用的大部分还是IPv4的地址，以下简称IP地址，IP地址由32位二进制数组成，为便于使用，常以XXX.XXX.XXX.XXX形式表示。IP地址由两个字段组成：网络号(net-id)和主机号(host-id)，为方便IP地址管理，IP地址被分为五类，如下图：       其中A、B、C类地址为单播（unicast）地址；D类地址为组播（multicast）地址；E类地址为保留地址，以备将来的特殊用途。目前大量使用中的IP地址属于A、B、C三类地址。       A类地址范围：0.0.0.0～127.255.255.255         B类地址范围：128.</p>
      </div>
      <div class="card-footer">
        <span class="float-left">May 18, 2016</span>
        <a
        href="/posts/networkcomm/"
        class="float-right btn btn-outline-info btn-sm"
        >Read</a
        >
      </div>
    </div>
  </a>
</div>

        
        
      </div>
      
    </div>
  </div>

    </div>

    <footer class="container-fluid text-center align-content-center footer pb-2">
  <div class="container pt-5">
    <div class="row text-left">
      <div class="col-md-4 col-sm-12">
        <h5>Navigation</h5>
        
          <ul>
            
            <li class="nav-item">
              <a class="smooth-scroll" href="#home">Home</a>
            </li>
            
            <li class="nav-item">
              <a class="smooth-scroll" href="#about">About</a>
            </li>
            
            <li class="nav-item">
              <a class="smooth-scroll" href="#skills">Skills</a>
            </li>
            
            <li class="nav-item">
              <a class="smooth-scroll" href="#experiences">Experiences</a>
            </li>
            
            <li class="nav-item">
              <a class="smooth-scroll" href="#projects">Projects</a>
            </li>
            
            <li class="nav-item">
              <a class="smooth-scroll" href="#recent-posts">Recent Posts</a>
            </li>
            
          </ul>
        
      </div>
      <div class="col-md-4 col-sm-12">
        <h5>Contact Me</h5>
        <ul>
          
          <li><span>Email: </span> <span>zcc0388@gmail.com</span></li>
          
          <li><span>WeChat: </span> <span>zcc0388</span></li>
          
        </ul>
      </div>
      <div class="col-md-4 col-sm-12">
        
        <p>Stay up to date with email notification</p>
        <form>
          <div class="form-group">
            <input
              type="email"
              class="form-control"
              id="exampleInputEmail1"
              aria-describedby="emailHelp"
              placeholder="Enter email"
            />
            <small id="emailHelp" class="form-text text-muted"
              >We'll never share your email with anyone else.</small
            >
          </div>
          <button type="submit" class="btn btn-info">Submit</button>
        </form>
      </div>
    </div>
  </div>
  <hr />
  <div class="container">
    <div class="row text-left">
      <div class="col-md-4">
        <a id="theme" href="https://github.com/hossainemruz/toha" target="#">
          <img src="/assets/images/logo-inverted.png">
          Toha
        </a>
      </div>
      <div class="col-md-4">© 2019 Copyright.</div>
      <div class="col-md-4">
        Powered by <a href="https://gohugo.io/">Hugo
        <img
          src="/assets/images/hugo-logo-wide.svg"
          alt="Hugo Logo"
          height="18"
        />
        </a>
      </div>
    </div>
  </div>
</footer>

    <script src="/assets/js/jquery-3.4.1.min.js"></script>
<script src="/assets/js/bootstrap.min.js"></script>

<script src="/assets/js/navbar.js"></script>
<script src="/assets/js/jquery.filterizr.min.js"></script>


    
    
    <script src="/assets/js/list.js"></script>

  </body>
</html>
