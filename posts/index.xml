<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>All Posts - CC&#39;s Trip</title>
        <link>https://cctrip.github.io/posts/</link>
        <description>All Posts | CC&#39;s Trip</description>
        <generator>Hugo -- gohugo.io</generator><language>en</language><copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright><lastBuildDate>Sat, 16 Jan 2021 17:55:28 &#43;0800</lastBuildDate><atom:link href="https://cctrip.github.io/posts/" rel="self" type="application/rss+xml" /><item>
    <title>DevOps系列：开篇</title>
    <link>https://cctrip.github.io/devops_series/</link>
    <pubDate>Sat, 16 Jan 2021 17:55:28 &#43;0800</pubDate>
    <author>Author</author>
    <guid>https://cctrip.github.io/devops_series/</guid>
    <description><![CDATA[系列目录 《DevOps系列：开篇》
《DevOps系列：概述》
《DevOps系列：CMDB》
《DevOps系列：CI/CD》
《DevOps系列：监控》
《DevOps系列：SRE》
 1. 介绍 在Ops领域工作也接近8年了，也经历了从人工Ops&ndash;&gt;工具Ops&ndash;&gt;平台Ops的转变，最近想把自己的一些DevOps相关的学习和经验记录下来，整理成一个系列，算是对自己这么多年的工作经验的一个总结，也想对之后的发展想法做下自己的规划和判断。
 2. 当我们谈论Ops，我们在谈论什么 在《[译]当我们谈论Ops时，我们在谈论什么?》这篇文章中，讲述了关于Ops的一些东西，有兴趣的可以转到该文章看看，我自己也针对自己这些年的经验发表下自己的一些看法。
从软件行业来说，一个应用程序的周期包括立项、需求、设计、开发、测试、部署、维护、下线几个阶段。这种周期催生了不同的岗位、包括项目经理、产品经理、开发工程师、测试工程师、运维工程师等。
在初期阶段，可能是基于功能和管理的划分，以上不同的岗位就会归属于不同的部门，每个部门根据自己的职责做事情，产品经理思考和提出需求，开发人员开发应用程序，然后将应用程序交由测试人员测试，测试人员搭建本地环境，完成各种功能测试，再由测试人员交由运维人员做线上环境的搭建和维护，不同的人处理不同环境的应用程序。因此，纯Ops的概念的话更多的工作在于搭建线上环境，以及如何保障线上环境的稳定运行。在我看了，这种应该叫做业务-Ops，需要对软件的整个架构和业务功能熟悉，但是又不熟悉实际的代码实现。
随着规模和业务的扩张，就需要不断的增加机器，不断的扩张人员，人工成本线性增长。而业务也越来越复杂，部署监控的步骤或者额外的操作越来越多，那么就需要思考怎么对这些进行优化。这些优化的步骤基本应该就是整个运维体系的变更史了，我个人算是经历了大部分阶段。
 3. 运维体系的变更 3.1 人肉/脚本 在业务规模小的情况下，一个Ops可能只需要维护几台到十几台的设备，迭代需求少，可能一个月就做一次发布，在程序稳定的情况下，出故障的概率很小，Ops的工作内容更多的在于巡检以及甚至充当客服人员。而人员的操作的话，可能就会偏向于人工或者编写简单的脚本来执行。
3.2 工具化 随着业务的发展，机器规模可能扩张到上百台，机器的管理、部署、巡检这种操作在依赖于人工就很不方便，并且容易产生认为错误，因此开始催生了各种工具、例如ansible、puppet等、或者自己编写shell脚本集成工具等，这样在做机器管理时，就可以开始做区分，部署也更加快捷。
3.3 平台化 当业务更进一步的发展，机器规模可能扩张到上万台，人员也增加了很多，人员变动也很快，如果还是工具时代的话，操作需要的技术人员的技术要求相对比较高，人员变动的话，交接也比较困难，那么就开始考虑将各种各样的工具集成到一起，在通过web平台来做各种操作，这样，只需要部分的人员要求技术高，其他人员只需要通过web平台来执行操作即可，交接的话，也比较方便。
3.4 智能化 智能化的话，我个人目前还没接触到，本身来说，感觉还需要一大段的历程要走。
 4. DevOps 随着各种平台化的发展，以及不同团队的各种摩擦导致的交付效率的低下，开始催生了DevOps，越来越多的团队开始整合开发、测试、运维，做成一体化，职能开始出现变化，纯业务ops的工作开始交由开发人员通过平台处理，谁开发谁负责。一部分测试、运维人员开始往自动化方向发展，通过开发平台来输出。 关于DevOps，我们会再接下来的系列文章中细讲。
 ]]></description>
</item><item>
    <title>[译]当我们谈论Ops，我们在谈论什么</title>
    <link>https://cctrip.github.io/talk_ops/</link>
    <pubDate>Wed, 13 Jan 2021 17:55:28 &#43;0800</pubDate>
    <author>Author</author>
    <guid>https://cctrip.github.io/talk_ops/</guid>
    <description><![CDATA[原文链接：What the Ops are you talking about?
水平有限，本文不免存在遗漏或错误之处。如有疑问，请查阅原文。
 背景 两年前，我因为效率低下的领导而获得了耻辱。我的背景是数据科学和机器学习，因此，我当然从我的工程同事那边学习到了DevOps。至少我们认为是这样的。
令人费解的是，即使我们遵循了日常站立会议所有敏捷开发的良好实践，讨论我们的难点，也没有将难题扔给别人的态度。我们紧密合作并且相互友爱。但是开发效率依然缓慢，这令整个团队很沮丧。
两年过后，我终于掌握了DevOps的含义，并且理解了它在数据团队中如此的相同而又如此不同。
什么是Ops？ 在我们谈论以数据为中心的Ops时，先让我们从软件开始说起，
自从09年DevOps普及以来，软件行业就一直痴迷于各种Ops术语。十年前，从软件开发到部署的方法已经推陈出新。软件工程师开发应用，然后将其交付给运维工程师。该应用程序在部署期间经常中断，并在团队之间造成很大的摩擦。
DevOps实践的目的是简化部署过程。该想法是将自动化视为构建和部署软件应用程序的一等公民。
这种想法彻底改变了这个行业。许多组织开始建立跨职能团队来照顾整个SDLC。该团队将建立基础架构（基础工程师），开发应用程序（软件工程师），构建CI/CD管道（DevOps工程师），部署应用程序（每位工程师），然后连续监视和观察应用程序（站点可靠性工程师）。
在一个大团队里面，一个工程师可能只会有一项主要职能，但是在较小的团队中，一位工程师经常担任许多职务。理想的情况是使许多团队成员能够履行多项职能，从而消除瓶颈和关键人员的依存关系。所以实际上，
 DevOps并非是一项工作职能，而是更多的实践或文化。 在开始构建任何软件时都应采用它。
 随着DevOps的兴起，各种各样的Ops诞生了。
SecOps以安全性为核心，GitOps致力于持续交付，NetOps确保网络可以支持数据流，而ITOps则专注于软件交付之外的操作任务。但是，这些操作的基石都源自DevOps所承诺的愿景：
 在错误最小的情况下尽可能快的发布软件
  DataOps 🆚 MLOps 🆚 DevOps (and AIOps?) 注意：在本文中，分析团队是指使用SQL / PowerBI来生成业务洞察力的传统BI团队。 AI团队是指使用大数据技术构建高级分析和机器学习模型的团队。 有时他们是同一个团队，但我们将它们分开，以便更容易地解释概念。
五年前，“数据是新石油”一语成为炒作对象。世界各地的领导者开始倾注资源，建立大数据团队来挖掘这些宝贵的资产。这些团队交付的压力巨大—毕竟，我们如何才能兑现新石油的承诺？随着快速扩展，分析团队也经历了同样的痛苦。
然后，我们使这一切成为现实。
数据科学家成为21世纪最吃香的职业。我们正在建立和处于数据和分析的黄金时代。每个执行者都有一个仪表板，具有来自整个组织的数据和嵌入式预测模型的仪表板，每个客户都有基于其行为的个性化推荐。
但是，现在添加一个新功能需要花费数周甚至数月的时间。数据模型是混乱的并且没有人知道我们是使用信贷团队还是营销团队的活跃客户的定义。我们变得非常警惕将模型推向生成环境，因为我们不知道我们会破坏什么？
因此，以数据为中心的社区团结在一起，保证不会因管理不善的数据流程而造成的效率低下，从那时起，各种以数据为中心的OPS诞生了
要了解所有这些不同的Ops，让我们来看看数据如何在组织中流动的场景：
 数据是由与软件应用程序交互的客户生成的 软件将数据存储在其应用程序数据库中 分析团队从组织中的团队使用这些应用程序数据库构建ETL 然后，数据工程师将原始数据，合并的数据集（来自分析团队）和其他非结构化数据集摄取到某种形式的数据湖中 然后，数据科学家根据这些庞大的数据集建立模型 然后，这些模型采用用户生成的新数据进行预测。 然后，软件工程师将预测结果呈现给用户 并且周期继续  我们知道DevOps的诞生是由于开发团队和运维团队之间的摩擦。因此，想象一下运维，开发，分析和AI团队之间的4向界面所带来的令人头疼的问题。
为了说明不同的Ops如何解决上述过程，下面的图形绘制了每个作业功能在整个时间轴上执行的一些任务
理想情况下，应在项目开始时采用X-Ops文化，并在整个过程中实施实践.
总而言之，这就是每个Ops的意义
DevOps更快地交付软件 一系列实践旨在消除开发团队和运维团队之间的障碍，以便更快地构建和部署软件。工程团队通常采用它，包括DevOps工程师，基础架构工程师，软件工程师，站点可靠性工程师和数据工程师。
DataOps更快地交付数据 一系列实践旨在提高数据分析的质量和减少周期时间。DataOps主要的任务包括数据打标、数据测试、数据管道编排、数据版本控制和数据监控。分析和大数据团队是DataOps主要的支撑对象，但是任何生成和使用数据的人都应该采用良好的DataOps做法，其中包括数据分析师，BI分析师，数据科学家，数据工程师，有时还包括软件工程师。
MLOps更快地提供机器学习模型 一套设计，构建和管理可重现，可测试和可持续的ML支持软件的实践。对于大数据/机器学习团队，MLOps包含大多数DataOps任务和其他特定于ML的任务，例如模型版本控制，测试，验证和监视。
奖励：AIOps利用AI的功能增强了DevOps工具 有时人们会错误地将MLOps称为AIOps，但它们却大不相同。从Gartner：
 AIOps platforms utilize big data, modern machine learning and other advanced analytics technologies to directly and indirectly enhance IT operations (monitoring, automation and service desk) functions with proactive, personal and dynamic insight.]]></description>
</item><item>
    <title>Kubernetes系列：开篇</title>
    <link>https://cctrip.github.io/k8s_series/</link>
    <pubDate>Sun, 10 Jan 2021 17:55:28 &#43;0800</pubDate>
    <author>Author</author>
    <guid>https://cctrip.github.io/k8s_series/</guid>
    <description><![CDATA[系列目录 《Kubernetes系列：开篇》
《Kubernetes系列：概述》
《Kubernetes系列：架构》
《Kubernetes系列：CRI》
《Kubernetes系列：CNI》
《Kubernetes系列：CSI》
《Kubernetes系列：Service》
《Kubernetes系列：Ingress》
《Kubernetes系列：OAM》
《Kubernetes系列：调度》
 1. 介绍 最近整体工作在往云原生和k8s上迁移，想将自己对于k8s的一些学习心得和经验写成一个系列记录下来。
 ]]></description>
</item><item>
    <title>2021年flag</title>
    <link>https://cctrip.github.io/2021_flag/</link>
    <pubDate>Sat, 02 Jan 2021 17:55:28 &#43;0800</pubDate>
    <author>Author</author>
    <guid>https://cctrip.github.io/2021_flag/</guid>
    <description><![CDATA[2021年已经到来，在这里给自己列一个flag清单。
习惯成自然   每2周完成一个ARTS(Algorithm|Review|Technique|Share)
  完成12篇博客(每月一篇)
  完成4篇英文技术文章翻译(每季度一篇)
   读书清单  《性能之巅 洞悉系统、企业与云计算》 《Web性能权威指南》   极客时间清单  程序员的数学基础课 MySQL实战45讲   ]]></description>
</item><item>
    <title>监控系统</title>
    <link>https://cctrip.github.io/monitor/</link>
    <pubDate>Mon, 24 Aug 2020 17:55:28 &#43;0800</pubDate>
    <author>Author</author>
    <guid>https://cctrip.github.io/monitor/</guid>
    <description><![CDATA[为什么需要监控系统？ 两个场景 场景一 技术部门上线了一个新项目，系统宕机了，客户在访问时发现无法访问，客户 A 不知道如何处理，放弃了访问，客户 B 知道客服系统，告知了运营人员，运营人员自己访问后也发现无法访问，于是通知了测试人员，再由测试人员通知线上项目的负责人，由负责人来进行故障恢复。 整个流程中，能处理故障的人成了最后知道故障的人。
场景二 用户反馈访问某个系统很慢，通知技术人员排查问题，由于系统涉及的组件很多，技术人员没办法立即知道问题出在哪里，于是技术人员只能通过自己把整个数据流走完的方式来排查问题： 1、由入口开始排查问题，先确认网络是否丢包，延时是否过高，发现无异常。 2、于是排查服务所在机器的负载情况，以及服务相关日志 (未必有记录)，也无异常。 3、排查代码发现有做 sql 查询，于是根据 sql 手动到数据库执行，发现 sql 执行很慢。 4、于是排查数据库所在机器的负载情况，发现 cpu 一直处在 100% 状态，是数据库进程造成的。 5、通过查询相关执行 sql 发现有某个 sql 在执行复杂查询导致了 cpu 使用率一直很高，从而影响了其他 sql 查询。
极端情况下，技术人员可能需要把所有相关组件都排查一遍，才能发现问题出在哪里。
 场景解决方案 开头提到的两个场景应该是大部分技术人员都会碰到的问题，场景一是故障出现到故障处理的耗时问题，场景二是故障处理到故障恢复的耗时问题。
场景一的解决方式，可以由一个脚本或者一个系统，定时收集客户访问的 url 的返回状态码，如果出现错误的状态码达到一定次数，就发送邮件或者短信给到对应的负载人。
场景二的解决方式，可以由一个系统，定时收集所有组件的相关信息，然后通过聚合和数据展示，来提供一个全局的问题查看功能。
解决上面两种场景的系统就是监控系统。
 为什么要监控 监控一个系统有多个原因，一般包含如下几项
  分析趋势
数据库多大，增长速度如何？日活用户的增长速度？
  数据对比
增加了 redis 缓存后，访问速度较没增加前如何？这周和上周的访问速度有什么差异？
  告警
有东西故障了，或者即将故障，需要有人处理它。
  构建仪表盘
仪表盘应该可以回答有关服务的一些基本问题，通常会包含常见的指标
  临时性回溯分析
请求延迟刚刚大幅增加，有没有其他的现象同时发生？
   建立监控系统 监控系统基本组件 一个监控系统一般包含下面几个组件：]]></description>
</item><item>
    <title>运维进阶之SRE</title>
    <link>https://cctrip.github.io/sre/</link>
    <pubDate>Sun, 23 Aug 2020 17:55:28 &#43;0800</pubDate>
    <author>Author</author>
    <guid>https://cctrip.github.io/sre/</guid>
    <description><![CDATA[困局 计算机软件系统离开人通常是无法自主运行的，那要如何去运维一个日趋复杂的大型分布式计算机系统呢？
Dev/Ops分离团队模型 雇佣系统管理员(sysadmin)运维复杂的计算机系统是行业内一直以来的普遍做法，系统管理员的工作主要在于应对系统中产生的各种需要人工干预的事件，以及来自业务部门的变更需求。但随着系统变得复杂，组件越来越多，流量不断上升，相关的事件和变更需求也会越来越多，就需要招聘更多的系统管理员。系统管理员的日常工作和研发工程师的相差甚远，通常归属于两个不同的部门，开发部(Dev)和运维部(Ops)。也就是Dev/Ops分离团队模型。
但是这个模型存在两个无法避免的问题。
 直接成本。随着系统复杂度的增加，部署规模的扩大，团队的大小基本与系统负载成线性相关，共同成长。 间接成本。即研发团队和运维团队之间的沟通成本。研发团队想要&quot;随时随地发布新功能，没有任何阻拦&rdquo;，运维团队想要”一旦一个东西在生产环境中正常工作了，就不要再进行任何改动“。本质来说，两个团队的目标是互相矛盾的。   解决之道 DevOps  DevOps（开发 Development 与运维 Operations 的组合词）是一种文化、一场运动或实践，强调在自动化软件交付流程及基础设施变更过程中，软件开发人员与其他信息技术（IT）专业人员彼此之间的协作与沟通。它旨在建立一种文化与环境，使构建、测试、软件发布得以快速、频繁以及更加稳定地进行。
 SRE  SRE可以理解为DevOps的一种实践，SRE基本是在进行由运维团队完成的工作，但是雇佣具有软件专业知识的工程师，通过创造软件系统的方式来维护系统运行并替代传统模型中的人工操作。本质上，SRE是在用软件工程的思维和方法论，通过设计、构建自动化工具来完成以前由系统管理员人工操作完成的任务。
 SRE方法论 1. 确保长期关注研发工作 SRE团队应将运维工作限制在50%以内，并将剩余时间投入到研发项目上
2. 在保障SLO的前提下最大化迭代速度 错误预算，任何产品都不是，也不应该做到100%可靠，部门建立起一个合理的可靠性目标，错误预算等于”1-可靠性目标“，通过错误预算来最大化新功能上线的速度，同时保障服务质量。
3. 监控系统 监控系统是SRE团队监控服务质量和可用性的一个主要手段。一个监控系统应该只有三类输出：
 紧急警报(alert)，意味着收到警报的用户需要立即执行某种操作 工单(ticket)，意味着接受工单的用户应该执行某种操作，但是并发立即执行。 日志(logging)，平时没有人需要关注日志信息，但是日志信息依然被收集起来以备调试和事后分析时使用  4. 应急事件处理 可靠性是MTTF(平均失败时间)和MTTR(平均恢复时间)的函数。评价一个团队将系统恢复到正常情况的最有效的指标，就是MTTR。
任何需要人工操作的事情都只会延长恢复时间。但有时候人工介入不可避免时，可以通过事先预案并且将最佳方法记录到”运维手册“上来降低MTTR。
5. 变更管理 变更管理的最佳实践是使用自动化来完成以下几个项目：
 采用渐进式发布机制 迅速而准确地检测到问题的发生 当问题发生时，安全迅速的回滚  6. 需要预测和容量规划 需要预测和容量规划是保障一个业务有足够的容量和冗余度去服务预测中的未来需要。
容量规划有几个必需步骤：
 必须有一个准确的自然增长需求预测模型，需求预测的时间应该超过资源获取的时间 规划中必须有准确的非自然增长的需求来源的统计 必须有周期性压力测试，以便准确地将系统原始资源信息与业务容量对应起来。  7. 效率与性能 高效地利用各种资源是任何赢利性服务都要关心的，一个服务的利用率指标通常依赖于这个服务的工作方式以及对容量的配置与部署上。如果能通过密切关注一个服务的容量配置策略，进而改进其资源利用率，可以有效地降低系统的总成本。
 成为SRE 技能要求  – TCP/IP网络模型 (OSI模型)
– Unix/Linux 系统]]></description>
</item><item>
    <title>Nginx匹配机制总结</title>
    <link>https://cctrip.github.io/nginx_match/</link>
    <pubDate>Sat, 06 Jun 2020 17:55:28 &#43;0800</pubDate>
    <author>Author</author>
    <guid>https://cctrip.github.io/nginx_match/</guid>
    <description><![CDATA[背景 Nginx是一个当前主流的HTTP服务器和反向代理服务器，很多做WEB相关的同学基本都会用到，很多云厂商的七层负载均衡器也基本都是基于nginx实现的，个人在工作过程也算是经常接触，这篇文章主要想总结一下nginx的匹配机制，主要分为两块，一块是server的匹配，一块是location的匹配。
 Server匹配机制 配置过nginx的都知道，在一个http模块中是可以配置多个server模块的，并且多个server模块是可以配置相同的监听端口的，下面是一个简单的server配置例子：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  server { listen 80; server_name example.org www.example.org; ... } server { listen 80; server_name example.net www.example.net; ... } server { listen 80; server_name example.com www.example.com; ... }   当我们对nginx发起http请求后，nginx会拿到http请求中对应的 &quot;Host&quot; 头部跟server模块中的server_name进行匹配，根据匹配的server结果进入具体的server模块处理http请求。那么，它具体的匹配机制是怎样的呢？
首先，我们先简单了解下nginx内部server的相关结构，
其中listen和server_name在配置文件中的写法有：
 listen(可带default_server标识)  ip:port ip(监听80端口) port(监听所有地址)   server_name  www.example.com(完整域名) *.example.com(带通配符开头的域名) www.example.*(带通配符结尾的域名) ~^(www.]]></description>
</item><item>
    <title>Linux PAM模块</title>
    <link>https://cctrip.github.io/linux_pam/</link>
    <pubDate>Sun, 05 Apr 2020 17:55:28 &#43;0800</pubDate>
    <author>Author</author>
    <guid>https://cctrip.github.io/linux_pam/</guid>
    <description><![CDATA[概念 Linux-PAM（Pluggable Authentication Modules for Linux）是一套共享库,使本地系统管理员可以随意选择程序的认证方式。换句话说，不用(重新编写)重新编译一个包含PAM功能的应用程序，就可以改变它使用的认证机制，这种方式下，就算升级本地认证机制,也不用修改程序。
 工作机制 当应用程序希望与PAM交互以处理事件时，他们必须包括libpam，该libpam允许通过库提供的API进行通信。 当PAM看到必须处理的新事件时，它将查看/etc/pam.d中的相关配置文件，并确定在某些阶段必须使用哪些模块。
 /etc/pam.d配置文件介绍 配置文件语法
1  type control module-path module-arguments   配置文件分为四列
 第一列代表模块类型 第二列代表控制标记 第三列代表模块路径 第四列代表模块参数  类型 类型 是规则对应的管理组。它用于指定后续模块要与哪个管理组关联。
目前有四种类型:
  account
此模块类型执行基于非身份验证的帐户管理。 通常用于限制/允许对服务的访问，例如是否允许登录,是否达到最大用户数,或是root用户是否允许在这个终端登录等。
  auth
此模块为用户验证提供两方面服务。让应用程序提示用户输入密码或者其他标记，确认用户合法性；通过他的凭证许可权限，设定组成员关系或者其他优先权。
  password
此模块用于控制用户更改密码的全过程。
  session
此模块处理为用户提供服务之前/后需要做的些事情。包括：开启/关闭交换数据的信息，监视目录等，设置用户会话环境等。也就是说这是在系统正式进行服务提供之前的最后一道关口。
  如果在类型前加一个短横线 -，就表示如果找不到这个模块，导致无法被加载时，这一事件不会被记录在日志中。这个功能适用于那些认证时非必需的、安装时可能没被安装进系统的模块。
控制标记 流程栈（stack）
它是认证时执行步骤和规则的堆叠。在某个服务的配置文件中，它体现在了配置文件中的自上而下的执行顺序中。栈是可以被引用的，即在一个栈（或者流程）中嵌入另一个栈。
控制标记 规定如何处理PAM模块鉴别认证的结果，简而言之就是鉴别认证成功或者失败之后会发生什么事，如何进行控制。一般有两种形式，一种是比较常见的“关键字”方式，另一种则是用方括号（[]）包含的“value =action”方式。
关键字方式:
  required
如果本条目没有被满足，那最终本次认证一定失败，但认证过程不因此打断。整个栈运行完毕之后才会返回“认证失败”信号。
  requisite
如果本条目没有被满足，那本次认证一定失败，而且整个栈立即中止并返回错误信号。
  sufficient]]></description>
</item><item>
    <title>谈谈文件描述符</title>
    <link>https://cctrip.github.io/file_descriptor/</link>
    <pubDate>Sun, 29 Mar 2020 17:55:28 &#43;0800</pubDate>
    <author>Author</author>
    <guid>https://cctrip.github.io/file_descriptor/</guid>
    <description><![CDATA[概念 wiki解释，文件描述符在形式上是一个非负整数。实际上，它是一个索引值，指向内核为每一个进程所维护的该进程打开文件的记录表。当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。在程序设计中，一些涉及底层的程序编写往往会围绕着文件描述符展开。
一个文件描述符是一个数字，唯一标识一个在计算机的操作系统打开的文件。它描述了数据资源，以及如何访问该资源。
当程序要求打开文件（或其他数据资源，例如网络套接字）时，内核：
 授予访问权限。 在全局文件表中创建一个条目。 向软件提供该条目的位置。  该描述符是唯一的非负整数。系统上每个打开的文件至少存在一个文件描述符。
 细节 对于内核，所有打开的文件均由文件描述符引用。文件描述符是一个非负数。当我们打开现有文件或创建新文件时，内核将文件描述符返回到进程。当我们想读取或写入文件时，我们用文件描述符标识文件。
每个Linux进程（也许是守护程序除外）都应该具有三个标准的POSIX文件描述符：
   POSIX常数名称 文件描述符 描述     STDIN_FILENO 0 标准输入   STDOUT_FILENO 1 标准输出   STDERR_FILENO 2 标准误差    有三个“系统文件表”：有一个文件描述符表，它将文件描述符（小整数）映射到打开的文件表中的条目。打开文件表中的每个条目（除其他事项外）还包含文件偏移量和指向内存中inode表的指针。在打开的文件表中，每个open（）调用都有一个文件表条目，如果文件描述符是dup（）ed或fork（）ed，则共享该条目。
我们使用来自维基百科的示例来显示这些表的工作方式。这是一张照片： 单个进程的文件描述符，文件表和索引节点表。请注意，多个文件描述符可以引用相同的文件表条目（例如，由于dup系统调用），并且多个文件表条目可以依次引用同一个索引节点（如果已多次打开；则该表之所以仍然简化，是因为它通过文件名来表示索引节点，即使索引节点可以具有多个名称也是如此。文件描述符3没有引用文件表中的任何内容，表明它已关闭。
理解具体情况，需要了解由内核维护的 3 个数据结构：
 进程级 文件描述符表 ( file descriptor table ) 系统级 打开文件表 ( open file table ) 文件系统 i-node表 ( i-node table )  这 3 个数据结构之间的关系如图所示：]]></description>
</item><item>
    <title>理解SSL/TLS协议</title>
    <link>https://cctrip.github.io/tls/</link>
    <pubDate>Sun, 08 Jan 2017 17:55:28 &#43;0800</pubDate>
    <author>Author</author>
    <guid>https://cctrip.github.io/tls/</guid>
    <description><![CDATA[背景 早期我们在访问web时使用HTTP协议，该协议在传输数据时使用明文传输，明文传输带来了以下风险：
 信息窃听风险，第三方可以获取通信内容 信息篡改风险，第三方可以篡改通信内容 身份冒充风险，第三方可以冒充他人身份参与通信  为了解决明文传输所带来的风险，网景公司在1994年设计了SSL用于Web的安全传输协议，这是SSL的起源。IETF将SSL进行标准化，1999年公布了第一版TLS标准文件。随后又公布了 RFC 5246（2008年8月）与 RFC 6176 （2011年3月）。该协议在web中被广泛应用。
 SSL/TLS协议 TLS（Transport Layer Security，传输层安全协议），及其前身SSL（Secure Sockets Layer，安全套接层）是一种安全协议，目的是为互联网通信，提供安全及数据完整性保障。
TLS协议使用以下三种机制为信息通信提供安全传输：
 隐秘性，所有通信都通过加密后进行传播 身份认证，通过证书进行认证 可靠性，通过校验数据完整性维护一个可靠的安全连接   以TLS1.2为例说明TLS协议 TLS协议由TLS Record Protocol和TLS Handshake Protocol两层协议组成
TLS Record Protocol 该协议提供了连接安全的两个基本特性：
  连接私有
对称密码用于数据加密，这种对称加密是为每条连接唯一生成的并基于另一个人协商的秘密协议
  连接可靠
消息传输包括一条消息 使用密钥MAC进行完整性检查，安全哈希函数（例如， SHA-1等）用于MAC计算。
   TLS Handshake Protocol 该协议提供了连接安全的三个基本特性：
 可以使用非对称身份验证对等方的身份，或者 公钥，密码学等 共享密钥的协商是安全的 谈判可靠   一个TLS握手协议一般涉及以下步骤：
 交换hello信息用于算法协商，交换随机值，并检查会话是否恢复 交换必要的密码信息以允许客户端和服务端同意使用premaster secret 交换证书和密码信息以允许客户端和服务端进行身份验证 通过随机值和premaster secret生成master secret 向record layer提供安全参数 允许客户端和服务器验证其对等方具有计算出的相同安全参数，并且握手发生在没有被攻击者篡改的情况下  TLS握手的完整消息流   ClientHello]]></description>
</item></channel>
</rss>
