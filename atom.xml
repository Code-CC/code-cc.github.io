<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>CC&#39;s Blog</title>
  
  <subtitle>人生如逆旅。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://cctrip.github.io/"/>
  <updated>2020-03-28T16:36:19.670Z</updated>
  <id>http://cctrip.github.io/</id>
  
  <author>
    <name>Code.CC</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>文件描述符</title>
    <link href="http://cctrip.github.io/2020/03/29/file_descriptor/"/>
    <id>http://cctrip.github.io/2020/03/29/file_descriptor/</id>
    <published>2020-03-28T16:07:03.000Z</published>
    <updated>2020-03-28T16:36:19.670Z</updated>
    
    <content type="html"><![CDATA[<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p><a href="[https://zh.wikipedia.org/wiki/%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6](https://zh.wikipedia.org/wiki/文件描述符">wiki解释</a>)，文件描述符在形式上是一个非负整数。实际上，它是一个索引值，指向<a href="https://zh.wikipedia.org/wiki/内核" target="_blank" rel="noopener">内核</a>为每一个<a href="https://zh.wikipedia.org/wiki/进程" target="_blank" rel="noopener">进程</a>所维护的该进程打开文件的记录表。当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。在程序设计中，一些涉及底层的程序编写往往会围绕着文件描述符展开。</p><p>一个<strong>文件描述符</strong>是一个数字，唯一标识一个在计算机的操作系统打开的文件。它描述了数据资源，以及如何访问该资源。</p><p>当程序要求打开文件（或其他数据资源，例如网络套接字）时，内核：</p><ol><li>授予访问权限。</li><li>在全局文件表中创建一个条目。</li><li>向软件提供该条目的位置。</li></ol><p>该描述符是唯一的非负整数。系统上每个打开的文件至少存在一个文件描述符。</p><hr><h3 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h3><p>对于内核，所有打开的文件均由文件描述符引用。文件描述符是一个非负数。当我们打开现有文件或创建新文件时，内核将文件描述符返回到进程。当我们想读取或写入文件时，我们用文件描述符标识文件。</p><p>每个Linux进程（也许是守护程序除外）都应该具有三个标准的POSIX文件描述符：</p><table><thead><tr><th>POSIX常数名称</th><th>文件描述符</th><th>描述</th></tr></thead><tbody><tr><td>STDIN_FILENO</td><td>0</td><td>标准输入</td></tr><tr><td>STDOUT_FILENO</td><td>1</td><td>标准输出</td></tr><tr><td>STDERR_FILENO</td><td>2</td><td>标准误差</td></tr></tbody></table><p>有三个“系统文件表”：有一个文件描述符表，它将文件描述符（小整数）映射到打开的文件表中的条目。打开文件表中的每个条目（除其他事项外）还包含文件偏移量和指向内存中inode表的指针。在打开的文件表中，每个open（）调用都有一个文件表条目，如果文件描述符是dup（）ed或fork（）ed，则共享该条目。</p><p>我们使用来自维基百科的示例来显示这些表的工作方式。这是一张照片： <img src="/2020/03/29/file_descriptor/image/fd.png" alt="img"></p><p>单个进程的文件描述符，文件表和索引节点表。请注意，多个文件描述符可以引用相同的文件表条目（例如，由于dup系统调用），并且多个文件表条目可以依次引用同一个索引节点（如果已多次打开；则该表之所以仍然简化，是因为它通过文件名来表示索引节点，即使索引节点可以具有多个名称也是如此。文件描述符3没有引用文件表中的任何内容，表明它已关闭。</p><p>理解具体情况，需要了解由内核维护的 3 个数据结构：</p><ul><li>进程级 <strong>文件描述符表</strong> ( file descriptor table )</li><li>系统级 <strong>打开文件表</strong> ( open file table )</li><li>文件系统 <strong>i-node表</strong> ( i-node table )</li></ul><p>这 3 个数据结构之间的关系如 图-1 所示：</p><p><img src="/2020/03/29/file_descriptor/image/fd_detail.png" alt="img"></p><p>图-1：文件描述符、打开文件及 inode 关系</p><h3 id="文件描述符表"><a href="#文件描述符表" class="headerlink" title="文件描述符表"></a>文件描述符表</h3><p>内核为每个进程维护一个 <strong>文件描述符表</strong> ，该表每一条目都记录了单个文件描述符的相关信息，包括：</p><ul><li><strong>控制标志</strong> ( flags )，目前内核仅定义了一个，即 <code>close-on-exec</code></li><li><strong>打开文件描述体指针</strong></li></ul><h3 id="打开文件表"><a href="#打开文件表" class="headerlink" title="打开文件表"></a>打开文件表</h3><p>内核对所有打开的文件维护一个系统级别的 <strong>打开文件描述表</strong> ( open file description table )，简称 <strong>打开文件表</strong> 。 表中条目称为 <strong>打开文件描述体</strong> ( open file description )，存储了与一个打开文件相关的全部信息，包括：</p><ul><li><strong>文件偏移量</strong> ( file offset )，调用 read() 和 write() 更新，调用 lseek() 直接修改</li><li><strong>访问模式</strong> ，由 open() 调用设置，例如：只读、只写或读写等</li><li><strong>i-node 对象指针</strong></li></ul><h3 id="i-node-表"><a href="#i-node-表" class="headerlink" title="i-node 表"></a>i-node 表</h3><p>每个文件系统会为存储于其上的所有文件(包括目录)维护一个 i-node 表，单个 i-node 包含以下信息：</p><ul><li><strong>文件类型</strong> ( file type )，可以是常规文件、目录、套接字或 FIFO</li><li><strong>访问权限</strong></li><li><strong>文件锁列表</strong> ( file locks )</li><li><strong>文件大小</strong></li><li>等等</li></ul><p>i-node 存储在磁盘设备上，内核在内存中维护了一个副本，这里的 i-node 表为后者。 副本除了原有信息，还包括： <strong>引用计数</strong> (从打开文件描述体)、所在 <strong>设备号</strong> 以及一些临时属性，例如文件锁。</p><hr><h3 id="参数优化"><a href="#参数优化" class="headerlink" title="参数优化"></a>参数优化</h3><h4 id="1-系统最大的文件描述符数量"><a href="#1-系统最大的文件描述符数量" class="headerlink" title="1. 系统最大的文件描述符数量"></a>1. 系统最大的文件描述符数量</h4><p>系统文件最大值取决于内存大小，在kernel初始化时定义</p><p><a href="https://github.com/torvalds/linux/blob/master/fs/file_table.c" target="_blank" rel="noopener">代码</a>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * One file with associated inode and dcache is very roughly 1K. Per default</span></span><br><span class="line"><span class="comment"> * do not use more than 10% of our memory for files.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> __<span class="function">init <span class="title">files_maxfiles_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> n;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> nr_pages = totalram_pages();</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> memreserve = (nr_pages - nr_free_pages()) * <span class="number">3</span>/<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">memreserve = min(memreserve, nr_pages - <span class="number">1</span>);</span><br><span class="line">n = ((nr_pages - memreserve) * (PAGE_SIZE / <span class="number">1024</span>)) / <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">files_stat.max_files = <span class="keyword">max_t</span>(<span class="keyword">unsigned</span> <span class="keyword">long</span>, n, NR_FILE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由代码可知，file-max的值不超过内存的10%</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>获取total ram pages 和 PAGE_SIZE大小</span><br><span class="line"><span class="meta">$</span> getconf -a | grep "PAGE"</span><br><span class="line">PAGESIZE                           4096</span><br><span class="line">PAGE_SIZE                          4096</span><br><span class="line">_AVPHYS_PAGES                      565489</span><br><span class="line">_PHYS_PAGES                        1011579</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>查看系统最大打开文件描述符数</span><br><span class="line"><span class="meta">$</span> cat /proc/sys/fs/file-max</span><br><span class="line">399894</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>查看当前系统使用的打开文件描述符数</span><br><span class="line"><span class="meta">$</span> cat /proc/sys/fs/file-nr</span><br><span class="line">928  0 399894</span><br><span class="line">   |  |   |_ Max no. of file descriptors allowed on the system</span><br><span class="line">   |  |      </span><br><span class="line">   |  |__ Total free allocated file descriptors</span><br><span class="line">   |</span><br><span class="line">   |__  Total allocated file descriptors</span><br><span class="line">   </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>设置系统最大文件描述符</span><br><span class="line"><span class="meta">#</span>临时性</span><br><span class="line"><span class="meta">$</span> echo 1000000 &gt; /proc/sys/fs/file-max</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>永久性 </span><br><span class="line"><span class="meta">#</span>在/etc/sysctl.conf中设置</span><br><span class="line">fs.file-max = 1000000</span><br><span class="line"><span class="meta">$</span> sysctl -p</span><br></pre></td></tr></table></figure><h4 id="2-进程最大描述符"><a href="#2-进程最大描述符" class="headerlink" title="2. 进程最大描述符"></a>2. 进程最大描述符</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 查看某个进程的使用</span><br><span class="line"><span class="meta">$</span> ls -l /proc/2374/fd  | wc -l</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 进程最大打开文件描述符数</span><br><span class="line"><span class="meta">#</span>soft limit</span><br><span class="line"><span class="meta">$</span> ulimit -n</span><br><span class="line">65535</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>hard limit</span><br><span class="line"><span class="meta">$</span> ulimit -Hn</span><br><span class="line">65535</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>soft limit不能大于hard limit</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>设置</span><br><span class="line"><span class="meta">#</span>临时性</span><br><span class="line"><span class="meta">$</span> ulimit -Sn 1600000</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>永久性</span><br><span class="line"><span class="meta">$</span> vim /etc/security/limits.conf</span><br><span class="line">root soft nofile 65535</span><br><span class="line">root hard nofile 65535</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>设置nofile的hard limit还有一点要注意的就是hard limit不能大于/proc/sys/fs/nr_open</span><br></pre></td></tr></table></figure><h4 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">1. </span>所有进程打开的文件描述符数不能超过/proc/sys/fs/file-max</span><br><span class="line"></span><br><span class="line"><span class="bullet">2. </span>单个进程打开的文件描述符数不能超过user limit中nofile的soft limit</span><br><span class="line"></span><br><span class="line"><span class="bullet">3. </span>nofile的soft limit不能超过其hard limit</span><br><span class="line"></span><br><span class="line"><span class="bullet">4. </span>nofile的hard limit不能超过/proc/sys/fs/nr_open</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;[https://zh.wikipedia.org/wiki/%E6%96%87%E4%BB%B6%E6%8F%8F%E8
      
    
    </summary>
    
      <category term="technology" scheme="http://cctrip.github.io/categories/technology/"/>
    
    
      <category term="linux" scheme="http://cctrip.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>Hello,2019！</title>
    <link href="http://cctrip.github.io/2019/01/28/2019/"/>
    <id>http://cctrip.github.io/2019/01/28/2019/</id>
    <published>2019-01-28T06:59:07.000Z</published>
    <updated>2019-02-14T05:35:52.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Hello-2019"><a href="#Hello-2019" class="headerlink" title="Hello, 2019"></a>Hello, 2019</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Hello-2019&quot;&gt;&lt;a href=&quot;#Hello-2019&quot; class=&quot;headerlink&quot; title=&quot;Hello, 2019&quot;&gt;&lt;/a&gt;Hello, 2019&lt;/h3&gt;
      
    
    </summary>
    
      <category term="life" scheme="http://cctrip.github.io/categories/life/"/>
    
    
      <category term="life" scheme="http://cctrip.github.io/tags/life/"/>
    
  </entry>
  
  <entry>
    <title>谈谈HTTP</title>
    <link href="http://cctrip.github.io/2016/05/29/http/"/>
    <id>http://cctrip.github.io/2016/05/29/http/</id>
    <published>2016-05-29T07:07:03.000Z</published>
    <updated>2019-01-28T06:25:36.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h3><p>如今网络已经无处不在，人们通过网络获取浏览各种信息，其中，大部分都是通过浏览器访问各种网页来获取我们想要的信息，那么浏览器与网页(服务端)究竟是如何通信的呢？这就得从HTTP协议说起了，浏览器获取网页信息都是基于HTTP协议来处理的。</p><hr><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>HTTP（HyperText Transfer Protocol，超文本传输协议）是互联网上应用最为广泛的一种网络协议。设计HTTP最初的目的是为了提供一种发布和接收HTML页面的方法。通过HTTP或者HTTPS协议请求的资源由统一资源标识符（Uniform Resource Identifiers，URI）来标识。HTTP是一个应用层协议，由请求和响应构成，是一个标准的客户端服务器模型。其具有如下特点：</p><ul><li><p>支持客户/服务器模式。</p></li><li><p>简单快速：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有GET、HEAD、POST。每种方法规定了客户与服务器联系的类型不同。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。</p></li><li><p>灵活：HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记。</p></li><li><p>无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。</p></li><li><p>无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快</p></li></ul><p>PS：尽管TCP/IP协议是互联网上最流行的应用，HTTP协议中，并没有规定必须使用它或它支持的层。事实上，HTTP可以在任何互联网协议上，或其他网络上实现。HTTP假定其下层协议提供可靠的传输。因此，任何能够提供这种保证的协议都可以被其使用。因此也就是其在TCP/IP协议族使用TCP作为其传输层。</p><hr><h3 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h3><p>HTTP协议的通信过程永远是客户端发起请求(request)，服务器回送响应(respone)，如下图所示：</p><p><img src="/2016/05/29/http/image/5657919_2.jpg" alt=""></p><p>一个完整的HTTP操作称为一个事务，其流程可分为四步：</p><ul><li><p>建立连接(TCP三次握手)</p></li><li><p>客户端发送一个请求报文给服务器</p></li><li><p>服务器响应对应信息</p></li><li><p>客户端接收信息，然后断开连接</p></li></ul><hr><h3 id="请求和响应详解"><a href="#请求和响应详解" class="headerlink" title="请求和响应详解"></a>请求和响应详解</h3><h4 id="请求报文"><a href="#请求报文" class="headerlink" title="请求报文"></a>请求报文</h4><ul><li><p>请求行：由请求方法、URL和HTTP版本组成</p><p>  eg：GET /index.html HTTP/1.1</p><ul><li><p>请求方法</p><ul><li><p>GET：请求获取URI所标识的资源</p></li><li><p>HEAD：请求获取URI所标识的资源，但不传回资源的文本部分</p></li><li><p>POST：向指定URI资源提交数据，请求服务器进行处理</p></li><li><p>PUT：向指定URI资源上传其最新内容</p></li><li><p>DELETE：请求服务器删除URI所标识的资源</p></li><li><p>TRACE：回显服务器收到的请求，主要用于测试或诊断</p></li><li><p>OPTIONS：请求URI资源所支持的HTTP请求方法</p></li><li><p>CONNECT：HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。通常用于SSL加密服务器的链接</p></li></ul></li><li><p>URL</p><p>  请求的资源路径</p></li><li><p>协议版本</p><p>  现在大部分为HTTP/1.0 和 HTTP/1.1</p></li></ul></li></ul><ul><li><p>请求头部</p><p>  eg：host:<a href="http://www.google.com" target="_blank" rel="noopener">www.google.com</a></p><p>  host为必选，其他都为可选参数</p></li><li><p>空行</p></li><li><p>消息体</p><p>  请求所带的文本</p></li></ul><h4 id="响应报文"><a href="#响应报文" class="headerlink" title="响应报文"></a>响应报文</h4><ul><li><p>状态行：由协议版本、状态码和描述信息组成</p><p>  eg：HTTP/1.1 200 OK</p><ul><li><p>协议版本</p></li><li><p>状态码：用于告诉客户端，服务器是否产生预期的响应</p><ul><li><p>1XX：提示信息，表示请求已被成功接收，继续处理</p></li><li><p>2XX：成功，表示请求已被成功接收，理解</p></li><li><p>3XX：重定向，要完成请求必须进行更进一步的处理</p></li><li><p>4XX：客户端错误，请求有语法错误或请求无法实现</p></li><li><p>5XX：服务器端错误，服务器未能实现合法的请求</p></li></ul></li><li><p>描述信息</p></li></ul></li><li><p>响应头部</p></li><li><p>空行</p></li><li><p>消息体</p></li></ul><h4 id="一个例子"><a href="#一个例子" class="headerlink" title="一个例子"></a>一个例子</h4><p>访问codecc.xyz首页</p><ul><li>Request，首行为请求行，其余为请求头部</li></ul><p><img src="/2016/05/29/http/image/20160531232545.png" alt=""></p><ul><li>Respone，首行为响应状态行，空行前为响应头部，其余为响应数据</li></ul><p><img src="/2016/05/29/http/image/20160531232617.png" alt=""></p><hr><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h3&gt;&lt;p&gt;如今网络已经无处不在，人们通过网络获取浏览各种信息，其中，大部分都是通过浏览器访问各种网页来获取我们想要的信息，那么浏览器与
      
    
    </summary>
    
      <category term="technology" scheme="http://cctrip.github.io/categories/technology/"/>
    
    
      <category term="network" scheme="http://cctrip.github.io/tags/network/"/>
    
      <category term="web" scheme="http://cctrip.github.io/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>谈谈DNS</title>
    <link href="http://cctrip.github.io/2016/05/21/dns/"/>
    <id>http://cctrip.github.io/2016/05/21/dns/</id>
    <published>2016-05-21T12:53:01.000Z</published>
    <updated>2019-01-28T06:25:36.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h3><p>目前，我们大部分的网络通信都是基于TCP/IP协议的，而TCP/IP又基于IP地址作为唯一标识进行通信，随着需要记忆的IP地址数量的增多，肯定会超出我们的记忆能力范围，但如果使用一种利于人们的记忆的方式，如域名，例如”<a href="http://www.google.com&quot;，我们便可以轻松的记忆这种方式的标识，而不是繁杂的数字。而DNS(域名系统)就是为了可以使用这种方式提供服务的。" target="_blank" rel="noopener">www.google.com&quot;，我们便可以轻松的记忆这种方式的标识，而不是繁杂的数字。而DNS(域名系统)就是为了可以使用这种方式提供服务的。</a></p><hr><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>DNS(Domain Name System)，域名系统，它是因特网的一项服务。它作为将域名和IP地址相互映射的一个分布式数据库，能够使人更方便地访问互联网。DNS使用TCP和UDP端口53。当前，对于每一级域名长度的限制是63个字符，域名总长度则不能超过253个字符。</p><p>DNS Domain Namespace，DNS域命名空间，是一种分层树状结构，其格式如下:”<a href="http://www.google.com&quot;,以点&quot;.&quot;为分隔。结构如图所示：" target="_blank" rel="noopener">www.google.com&quot;,以点&quot;.&quot;为分隔。结构如图所示：</a></p><p><img src="/2016/05/21/dns/image/607348-20160301212335189-776690379.gif" alt=""></p><ul><li><p>根域：绝对域名(FQDN)，以点”.”结尾的域名</p></li><li><p>顶级域：用来指示某个国家/地区或组织使用的名称的类型名称，例如.com</p></li><li><p>二级域：个人或组织在因特网上使用的注册名称，例如google.com</p></li><li><p>子域：已注册的二级域名派生的域名，一般就是网站名，例如<a href="http://www.google.com" target="_blank" rel="noopener">www.google.com</a></p></li><li><p>主机名：标识网络上的特定计算机，例如h1.<a href="http://www.google.com" target="_blank" rel="noopener">www.google.com</a></p></li></ul><p>DNS资源记录：(即映射关系，通常由域名管理员进行配置)，常见类型如下：</p><ul><li><p>SOA：起始授权机构</p></li><li><p>NS：名称服务器</p></li><li><p>MX：邮件服务器</p></li><li><p>A：IP地址(最常用，映射IP地址)</p></li><li><p>CNAME：别名(较常用，映射到其他域名)</p></li></ul><hr><p>　</p><h3 id="DNS工作原理"><a href="#DNS工作原理" class="headerlink" title="DNS工作原理"></a>DNS工作原理</h3><p>当我们请求一个域名时，会通过DNS服务器将域名解析成IP访问最终的主机，那么，DNS是如何查询到域名所对应的IP并返回给我们的呢？请工作机制如图所示：</p><p><img src="/2016/05/21/dns/image/607348-20160301205942986-1456220290.png" alt=""></p><p>当我们请求一个域名时，直到获取到IP地址，整个过程是如何工作的？以请求<a href="http://www.codecc.xyz为例：" target="_blank" rel="noopener">www.codecc.xyz为例：</a></p><ol><li><p>首先，我们的主机会去查找本地的hosts文件和本地DNS解析器缓存，如果hosts文件和本地DNS缓存存在<a href="http://www.codecc.xyz和IP的映射关系，则完成域名解析，请求该IP地址，否则进入第二步。" target="_blank" rel="noopener">www.codecc.xyz和IP的映射关系，则完成域名解析，请求该IP地址，否则进入第二步。</a></p></li><li><p>当hosts和本地DNS解析器缓存都没有对应的网址映射关系，则会根据机器(/etc/reslove.conf)配置的本地DNS服务器进行查询，此服务器收到查询时，如果要查询的域名在本地配置区域资源或者缓存中存在映射关系，则跳到步骤9，将解析结果直接返回给客户机。</p></li></ol><p>PS：一二步骤为递归查询，其余步骤为迭代查询</p><ol start="3"><li><p>若本地DNS服务器不存在该域名的映射关系，就把请求发送至13台根DNS服务器。</p></li><li><p>根DNS服务器会判断这个域名(.xyz)由谁来授权管理，并返回一个负责该顶级域的DNS服务器的一个IP给本地DNS服务器。</p></li><li><p>本地DNS服务器收到该IP后，会再将查询请求发送至(.xyz)所在的DNS服务器。</p></li><li><p>如果(.xyz)的DNS服务器无法解析该域名，就会去判断这个二级域名(codecc.xyz)的管理者，返回一个负责该二级域的DNS服务器的IP给本地DNS服务器。</p></li><li><p>本地DNS服务器收到该IP后，会再次将查询请求发送至(codecc.xyz)所在的DNS服务器。</p></li><li><p>(codecc.xyz)的DNS服务器会存有<a href="http://www.codecc.xzy的映射关系，将解析后的IP返回给本地DNS服务器" target="_blank" rel="noopener">www.codecc.xzy的映射关系，将解析后的IP返回给本地DNS服务器</a></p></li><li><p>本地DNS服务器根据查询到的解析IP发送给客户机，至此，DNS解析完成。</p></li></ol><hr><h3 id="常用DNS查询命令"><a href="#常用DNS查询命令" class="headerlink" title="常用DNS查询命令"></a>常用DNS查询命令</h3><ul><li><p>windows：</p><ul><li><p><code>nslookup 域名</code></p><p><img src="/2016/05/21/dns/image/607348-20160420012038241-52598954.png" alt=""></p></li></ul></li><li><p>Linux：</p><ul><li><p><code>nslookup 域名</code></p><p><img src="/2016/05/21/dns/image/607348-20160420012104335-886114220.png" alt=""></p></li><li><p><code>dig 域名</code></p><p><img src="/2016/05/21/dns/image/607348-20160420012127523-1968920086.png" alt=""></p></li></ul></li></ul><hr><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://en.wikipedia.org/wiki/Domain_Name_System" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Domain_Name_System</a></p><p><a href="https://technet.microsoft.com/en-us/library/cc772774(v=ws.10" target="_blank" rel="noopener">https://technet.microsoft.com/en-us/library/cc772774(v=ws.10).aspx</a>.aspx)</p><p><a href="">《TCP/IP详解卷1：协议》</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h3&gt;&lt;p&gt;目前，我们大部分的网络通信都是基于TCP/IP协议的，而TCP/IP又基于IP地址作为唯一标识进行通信，随着需要记忆的IP地
      
    
    </summary>
    
      <category term="technology" scheme="http://cctrip.github.io/categories/technology/"/>
    
    
      <category term="network" scheme="http://cctrip.github.io/tags/network/"/>
    
  </entry>
  
  <entry>
    <title>理解系统启动过程</title>
    <link href="http://cctrip.github.io/2016/05/21/systemstart/"/>
    <id>http://cctrip.github.io/2016/05/21/systemstart/</id>
    <published>2016-05-21T11:02:01.000Z</published>
    <updated>2019-01-28T06:25:36.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>Linux是一种自由和开放源代码的类UNIX操作系统。该操作系统的内核由林纳斯·托瓦兹在1991年10月5日首次发布。在加上用户空间的应用程序之后，成为Linux操作系统。Linux是自由软件和开放源代码软件发展中最著名的例子。</p><p>接触Linux的时间也不算短了，一直都是直接使用Linux操作系统进行一些工作，很少去了解系统从开机到能使用的整个过程，感觉有需要好好理解下整个系统的启动过程，故写这篇博客加深一下理解。</p><hr><h3 id="启动过程"><a href="#启动过程" class="headerlink" title="启动过程"></a>启动过程</h3><p>先通过一张图来简单了解下整个系统启动的流程，整个过程基本可以分为<font color="blue">POST–&gt;BIOS–&gt;MBR(GRUB)–&gt;Kernel–&gt;Init–&gt;Runlevel</font>。下面会详细说明每个过程的作用。</p><p><img src="/2016/05/21/systemstart/image/607348-20151229231206354-919070678.png" alt=""></p><ul><li><p>BIOS</p><p>  BIOS(Basic Input/Output System)，基本输入输出系统，该系统存储于主板的ROM芯片上，计算机在开机时，会最先读取该系统，然后会有一个加电自检过程，这个过程其实就是检查CPU和内存，计算机最基本的组成单元(控制器、运算器和存储器)，还会检查其他硬件，若没有异常就开始加载BIOS程序到内存当中。详细的BIOS功能，这边就不说了，BIOS主要的一个功能就是存储了磁盘的启动顺序，BIOS会按照启动顺序去查找第一个磁盘头的MBR信息，并加载和执行MBR中的Bootloader程序，若第一个磁盘不存在MBR，则会继续查找第二个磁盘(PS：启动顺序可以在BIOS的界面中进行设置)，一旦BootLoader程序被检测并加载内存中，BIOS就将控制权交接给了BootLoader程序。</p></li></ul><ul><li><p>MBR</p><p>  MBR(Master Boot Record)，主引导记录，MBR存储于磁盘的头部，大小为512bytes，其中，446bytes用于存储BootLoader程序，64bytes用于存储分区表信息，最后2bytes用于MBR的有效性检查。</p></li></ul><ul><li><p>GRUB</p><p>  GRUB(Grand Unified Bootloader)，多系统启动程序，其执行过程可分为三个步骤：</p><ul><li><p>Stage1：这个其实就是MBR，它的主要工作就是查找并加载第二段Bootloader程序(stage2)，但系统在没启动时，MBR根本找不到文件系统，也就找不到stage2所存放的位置，因此，就有了stage1_5</p></li><li><p>Stage1_5：该步骤就是为了识别文件系统</p></li><li><p>Stage2：GRUB程序会根据/boot/grub/grub.conf文件查找Kernel的信息，然后开始加载Kernel程序，当Kernel程序被检测并在加载到内存中，GRUB就将控制权交接给了Kernel程序。</p><p>  PS：实际上这个步骤/boot还没被挂载，GRUB直接识别grub所在磁盘的文件系统，所以实际上应该是/grub/grub.conf文件，该配置文件的信息如下：</p><p>  grub.conf:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#boot=/dev/sda</span><br><span class="line"></span><br><span class="line">default=0    #设定默认启动的title的编号，从0开始</span><br><span class="line"></span><br><span class="line">timeout=5    #等待用户选择的超时时间</span><br><span class="line"></span><br><span class="line">splashimage=(hd0,0)/boot/grub/splash.xpm.gz  #GRUB的背景图片</span><br><span class="line"></span><br><span class="line">hiddenmenu   #隐藏菜单</span><br><span class="line"></span><br><span class="line">title CentOS (2.6.18-194.el5PAE)    #内核标题</span><br><span class="line"></span><br><span class="line">root (hd0,0)       #内核文件所在的设备</span><br><span class="line"></span><br><span class="line">kernel /vmlinuz-2.6.18-194.el5PAE ro root=LABEL=/   #内核文件路径以及传递给内核的参数</span><br><span class="line"></span><br><span class="line">initrd /initrd-2.6.18-194.el5PAE.img                #ramdisk文件路径</span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li><p>Kernel</p><p>  Kernel，内核，Kernel是Linux系统最主要的程序，实际上，Kernel的文件很小，只保留了最基本的模块，并以压缩的文件形式存储在硬盘中，当GRUB将Kernel读进内存，内存开始解压缩内核文件。讲内核启动，应该先讲下initrd这个文件，</p><p>  initrd(Initial RAM Disk)，它在stage2这个步骤就被拷贝到了内存中，这个文件是在安装系统时产生的，是一个临时的根文件系统(rootfs)。因为Kernel为了精简，只保留了最基本的模块，因此，Kernel上并没有各种硬件的驱动程序，也就无法识rootfs所在的设备，故产生了initrd这个文件，该文件装载了必要的驱动模块，当Kernel启动时，可以从initrd文件中装载驱动模块，直到挂载真正的rootfs，然后将initrd从内存中移除。</p><p>  Kernel会以只读方式挂载根文件系统，当根文件系统被挂载后，开始装载第一个进程(用户空间的进程)，执行/sbin/init，之后就将控制权交接给了init程序。</p></li></ul><ul><li><p>Init</p><p>  init，初始化，顾名思义，该程序就是进行OS初始化操作，实际上是根据/etc/inittab(定义了系统默认运行级别)设定的动作进行脚本的执行，第一个被执行的脚本为/etc/rc.d/rc.sysinit，这个是真正的OS初始化脚本，简单讲下这个脚本的任务(可以去看看实际脚本，看看都做了什么)：</p><ul><li>激活udev和selinux;</li><li>根据/etc/sysctl.conf文件，来设定内核参数;</li><li>设定系统时钟;</li><li>装载硬盘映射;</li><li>启用交换分区;</li><li>设置主机名;</li><li>根文件系统检测，并以读写方式重新挂载根文件系统;</li><li>激活RAID和LVM设备;</li><li>启用磁盘配额;</li><li>根据/etc/fstab，检查并挂载其他文件系统;</li><li><p>清理过期的锁和PID文件</p><p>执行完后，根据配置的启动级别，执行对应目录底下的脚本，最后执行/etc/rc.d/rc.local这个脚本，至此，系统启动完成。　　</p></li></ul></li><li><p>Runlevel</p><p>  runlevel，运行级别，不同的级别会启动的服务不一样，init会根据定义的级别去执行相应目录下的脚本，Linux的启动级别分为以下几种：</p><p>  0：关机模式</p><p>  1：单一用户模式(直接以管理员身份进入)</p><p>  2：多用户模式（无网络）</p><p>  3：多用户模式（命令行）</p><p>  4：保留</p><p>  5：多用户模式（图形界面）</p><p>  6：重启</p><p>  在不同的运行级别下，/etc/rc.d/rc这个脚本会分别执行不同目录下的脚本：</p><p>  Runlevel 0 – /etc/rc.d/rc0.d/</p><p>  Runlevel 1 – /etc/rc.d/rc1.d/</p><p>  Runlevel 2 – /etc/rc.d/rc2.d/</p><p>  Runlevel 3 – /etc/rc.d/rc3.d/</p><p>  Runlevel 4 – /etc/rc.d/rc4.d/</p><p>  Runlevel 5 – /etc/rc.d/rc5.d/</p><p>  Runlevel 6 – /etc/rc.d/rc6.d/</p><p>  这些目录下的脚本只有K*和S*开头的文件，K开头的文件为开机需要执行关闭的服务，S开头的文件为开机需要执行开启的服务。</p></li></ul><hr><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="http://www.thegeekstuff.com/2011/02/linux-boot-process/" target="_blank" rel="noopener">http://www.thegeekstuff.com/2011/02/linux-boot-process/</a></p><p><a href="http://www.ibm.com/developerworks/library/l-linuxboot/" target="_blank" rel="noopener">http://www.ibm.com/developerworks/library/l-linuxboot/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;Linux是一种自由和开放源代码的类UNIX操作系统。该操作系统的内核由林纳斯·托瓦兹在1991年10月5日首次发布。在加上用户空间的应用程
      
    
    </summary>
    
      <category term="technology" scheme="http://cctrip.github.io/categories/technology/"/>
    
    
      <category term="system" scheme="http://cctrip.github.io/tags/system/"/>
    
  </entry>
  
  <entry>
    <title>WEB安全之CSP</title>
    <link href="http://cctrip.github.io/2016/05/20/webcsp/"/>
    <id>http://cctrip.github.io/2016/05/20/webcsp/</id>
    <published>2016-05-20T15:11:11.000Z</published>
    <updated>2019-01-28T06:25:36.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>内容安全策略(Content-Security-Policy，CSP)：是一种web应用技术用于帮助缓解大部分类型的内容注入攻击，包括XSS攻击和数据注入等，这些攻击可实现数据窃取、网站破坏和作为恶意软件分发版本等行为。该策略可让网站管理员指定客户端允许加载的各类可信任资源。</p><hr><h3 id="浏览器支持"><a href="#浏览器支持" class="headerlink" title="浏览器支持"></a>浏览器支持</h3><p><img src="/2016/05/20/webcsp/image/607348-20151208141131543-187859986.png" alt=""></p><p>统计来源：<a href="http://caniuse.com/#feat=contentsecuritypolicy" target="_blank" rel="noopener">caniuse.com/contentsecuritypolicy</a> &amp; <a href="https://hacks.mozilla.org/2013/05/content-security-policy-1-0-lands-in-firefox-aurora/" target="_blank" rel="noopener">Mozilla</a></p><hr><h3 id="指令参考"><a href="#指令参考" class="headerlink" title="指令参考"></a>指令参考</h3><p>Content-Security-Policy 响应头的值可配置一个或多个，多个指令以分号;隔开。</p><table><thead><tr><th>指令</th><th>示例</th><th>描述    </th></tr></thead><tbody><tr><td> default-src</td><td>‘self’ cdn.example.com</td><td>默认配置，若其他指令没有配置，都以此配置的规则为准</td></tr><tr><td> script-src</td><td>‘self’ js.example.com</td><td>定义允许加载的JavaScript来源</td></tr><tr><td> style-src</td><td>‘self’ css.example.com</td><td>定义允许加载的样式表来源</td></tr><tr><td> img-src</td><td>‘self’ img.example.com</td><td>定义允许加载的图片来源</td></tr><tr><td> connect-src</td><td>‘self’</td><td>适用于XMLHttpRequest(AJAX),WebSocket或EventSource，当为不允许的来源，浏览器返回一个400的状态码。</td></tr><tr><td> font-src</td><td>font.example.com</td><td>定义允许加载的字体来源</td></tr><tr><td> object-src</td><td>‘self’</td><td>定义允许加载的插件来源.eg,&lt;object>,&lt;embed>或&lt;applet></td></tr><tr><td> media-src</td><td>media.example.com</td><td>定义允许加载的audio和video.eg,HTML5,&lt;audio>,&lt;video>元素</td></tr><tr><td> frame-src</td><td>‘self’</td><td>定义允许加载的框架来源</td></tr><tr><td> sandbox</td><td>allow-forms allow-scripts</td><td>授权一个沙箱用来请求具有iframe sanbox等类似属性的资源,该沙箱默认为同源策略,禁止弹出窗口,执行插件和脚本.若要允许其他,可增加配置:allow-forms,allow-same-origin,allow-scripts,allow-top-navigation</td></tr><tr><td> report-uri</td><td>/some-report-uri</td><td>该配置让浏览器发送一个失败报告到指定的路径，也可以增加-Report-only到HTTP头,让浏览器只发送报告(不做阻止动作)</td></tr></tbody></table><hr><h3 id="来源配置参考"><a href="#来源配置参考" class="headerlink" title="来源配置参考"></a>来源配置参考</h3><p>所有的指令都要在配置后面添加来源列表，多个来源列表可用空格隔开，*和none只能存在一个。</p><table><thead><tr><th>指令</th><th>示例</th><th>描述    </th></tr></thead><tbody><tr><td> *</td><td>img-src *</td><td>无限制，允许所有</td></tr><tr><td> ‘none’</td><td>object-src ‘none’</td><td>禁止加载任何路径的资源</td></tr><tr><td> ‘self’</td><td>script-src ‘self’</td><td>允许加载同源的资源</td></tr><tr><td> data:</td><td>img-src ‘self’ data:</td><td>允许通过数据模式加载资源</td></tr><tr><td> domain.ccc.com</td><td>img-src img.ccc.com</td><td>允许加载匹配域名的资源</td></tr><tr><td> *.ccc.com</td><td>img-src *.ccc.com</td><td>允许加载匹配域名的资源</td></tr><tr><td> <a href="https://img.ccc.com" target="_blank" rel="noopener">https://img.ccc.com</a></td><td>img-src <a href="https://img.ccc.com" target="_blank" rel="noopener">https://img.ccc.com</a></td><td>允许加载匹配https方式的域名资源</td></tr><tr><td> https:</td><td>img-src https:</td><td>允许加载所有匹配https方式的资源</td></tr><tr><td> ‘unsafe-inline’</td><td>script-src ‘unsafe-inline’</td><td>允许使用内联元素,类似,Style attribute,onclick,scripttag bodies</td></tr><tr><td> ‘unsafe-eval’</td><td>script-src ‘unsafe-eval’</td><td>允许不安全的动态编码，例如eval()</td></tr></tbody></table><hr><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><ul><li><p>只允许加载同源的所有资源</p><p>  <code>default-src &#39;self&#39;;</code></p></li><li><p>支持*号匹配</p><p>  <code>default-src &#39;self&#39; https://*.ccc.com:*;</code></p></li><li><p>只允许加载同源的脚本</p><p>  <code>script-src &#39;self&#39;;</code></p></li><li><p>只允许加载同源的和<a href="http://www.ccc.com的脚本" target="_blank" rel="noopener">www.ccc.com的脚本</a></p><p>  <code>script-src &#39;self&#39; www.ccc.com;</code></p></li></ul><hr><h3 id="常见配置"><a href="#常见配置" class="headerlink" title="常见配置"></a>常见配置</h3><ul><li><p>该策略允许加载同源的图片、脚本、AJAX和CSS资源，并阻止加载其他任何资源，对于大多数网站是一个不错的配置。</p><p>  <code>default-src &#39;none&#39;; script-src &#39;self&#39;; connect-src &#39;self&#39;; img-src &#39;self&#39;; style-src &#39;self&#39;;</code></p></li></ul><ul><li><p>被禁止时的报错信息：</p><p>  谷歌浏览器可通过谷歌开发工具查看该报错，通常是按F12</p>  <font color="red">Refused to load the script ‘script-uri’ because it violates the following Content Security Policy directive: “your CSP directive”.</font><p>  Firefox 可通过 Web Developer Tools 查看报错</p>  <font color="red">Content Security Policy: A violation occurred for a report-only CSP policy (“An attempt to execute inline scripts has been blocked”). The behavior was allowed, and a CSP report was sent.</font></li></ul><hr><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="http://content-security-policy.com/" target="_blank" rel="noopener">http://content-security-policy.com/</a></p><p><a href="https://developer.mozilla.org/en-US/docs/Web/Security/CSP" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/docs/Web/Security/CSP</a></p><p><a href="http://www.w3.org/TR/CSP2/" target="_blank" rel="noopener">http://www.w3.org/TR/CSP2/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h3&gt;&lt;p&gt;内容安全策略(Content-Security-Policy，CSP)：是一种web应用技术用于帮助缓解大部分类型的内容注入攻击，包括XSS
      
    
    </summary>
    
      <category term="technology" scheme="http://cctrip.github.io/categories/technology/"/>
    
    
      <category term="web" scheme="http://cctrip.github.io/tags/web/"/>
    
      <category term="security" scheme="http://cctrip.github.io/tags/security/"/>
    
  </entry>
  
  <entry>
    <title>理解SSL/TLS协议</title>
    <link href="http://cctrip.github.io/2016/05/19/tls/"/>
    <id>http://cctrip.github.io/2016/05/19/tls/</id>
    <published>2016-05-18T16:43:26.000Z</published>
    <updated>2019-01-28T06:25:36.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>早期我们在访问web时使用HTTP协议，该协议在传输数据时使用明文传输，明文传输带来了以下风险：</p><ul><li>信息窃听风险，第三方可以获取通信内容</li><li>信息篡改风险，第三方可以篡改通信内容</li><li>身份冒充风险，第三方可以冒充他人身份参与通信</li></ul><p>为了解决明文传输所带来的风险，网景公司在1994年设计了SSL用于Web的安全传输协议，这是SSL的起源。IETF将SSL进行标准化，1999年公布了第一版TLS标准文件。随后又公布了 RFC 5246（2008年8月）与 RFC 6176 （2011年3月）。该协议在web中被广泛应用。</p><hr><h3 id="SSL-TLS协议"><a href="#SSL-TLS协议" class="headerlink" title="SSL/TLS协议"></a>SSL/TLS协议</h3><p>TLS（Transport Layer Security，传输层安全协议），及其前身SSL（Secure Sockets Layer，安全套接层）是一种安全协议，目的是为互联网通信，提供安全及数据完整性保障。</p><p>TLS协议使用以下三种机制为信息通信提供安全传输：</p><ul><li>隐秘性，所有通信都通过加密后进行传播</li><li>身份认证，通过证书进行认证</li><li>可靠性，通过校验数据完整性维护一个可靠的安全连接</li></ul><hr><h3 id="工作机制"><a href="#工作机制" class="headerlink" title="工作机制"></a>工作机制</h3><p>TLS协议由两部分组成，包括（TLS Record Layer,TLS handshake protocol）</p><ul><li><p>Record Layer：</p><p>  为每条信息提供一个header和在尾部生成一个从Message Authentication Code (MAC) 得到的hash值，其中header由5 bytes组成，分别是协议说明(1bytes),协议版本(2bytes)和长度(2bytes)，跟在header后面的协议信息长度不得超过16384bytes。　</p></li><li><p>Handshake Protocol：</p><p>  开始一个安全连接需要客户端和服务端经过反复的建立握手。一个TLS握手需要经过如下几个步骤：</p><p>  <img src="/2016/05/19/tls/image/607348-20160224221716880-1764174375.png" alt=""></p></li></ul><p>首先还是要经过TCP三次握手建立连接，然后才是TLS握手的开始：</p><ul><li><p>ClientHello：Client端将自己的TLS协议版本，加密套件，压缩方法，随机数，SessionID(未填充)发送给Server端</p></li><li><p>ServerHello：Server端将选择后的SSL协议版本，压缩算法，密码套件，填充SessionID，生成的随机数等信息发送给Client端</p></li><li><p>ServerCertificates：Server端将自己的数字证书(包含公钥)，发送给Client端。(证书需要从数字证书认证机构(CA)申请，证书是对于服务端的一种认证)，若要进行更为安全的数据通信，Server端还可以向Client端发送Cerficate Request来要去客户端发送对方的证书进行合法性的认证。</p></li><li><p>ServerHelloDone：当完成ServerHello后，Server端会发送Server Hello Done的消息给客户端，表示ServerHello 结束了。</p></li><li><p>ClientKeyExchage：当Client端收到Server端的证书等信息后，会先对服务端的证书进行检查，检查证书的完整性以及证书跟服务端域名是否吻合，然后使用加密算法生成一个PreMaster Secret，并通过Server端的公钥进行加密，然后发送给Server端。</p></li><li><p>ClientFinishd：Client端会发送一个ChangeCipherSpec(一种协议，数据只有一字节)，用于告知Server端已经切换到之前协商好的加密套件的状态，准备使用之前协商好的加密套件加密数据并进行传输了。然后使用Master Secret(通过两个随机数、PreMaster Secret和加密算法计算得出)加密一段Finish的数据传送给服务端，此数据是为了在正式传输应用数据之前对刚刚握手建立起来的加解密通道进行验证。</p></li><li><p>Server Finishd：Sever端在接收到Client端传过来的加密数据后，使用私钥对这段加密数据进行解密，并对数据进行验证，然后会给客户端发送一个ChangeCipherSpec，告知客户端已经切换到协商过的加密套件状态，准备使用加密套件加密数据并传输了。之后，服务端也会使用Master Secret加密一段Finish消息发送给客户端，以验证之前通过握手建立起来的加解密通道是否成功。</p></li></ul><p>根据之前的握手信息，如果客户端和服务端都能对Finish信息进行正常加解密且消息正确的被验证，则说明握手通道已经建立成功。</p><p>接下来，双方所有的通信数据都通过Master Secret进行加密后传输。　　　　</p><hr><h3 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h3><p><a href="https://en.wikipedia.org/wiki/Transport_Layer_Security" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Transport_Layer_Security</a></p><p><a href="https://www.sans.org/reading-room/whitepapers/protocols/ssl-tls-beginners-guide-1029" target="_blank" rel="noopener">https://www.sans.org/reading-room/whitepapers/protocols/ssl-tls-beginners-guide-1029</a></p><p><a href="https://support.microsoft.com/en-us/kb/257591" target="_blank" rel="noopener">https://support.microsoft.com/en-us/kb/257591</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h3&gt;&lt;p&gt;早期我们在访问web时使用HTTP协议，该协议在传输数据时使用明文传输，明文传输带来了以下风险：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;信息窃听风险，第
      
    
    </summary>
    
      <category term="technology" scheme="http://cctrip.github.io/categories/technology/"/>
    
    
      <category term="security" scheme="http://cctrip.github.io/tags/security/"/>
    
  </entry>
  
  <entry>
    <title>简单理解计算机通信</title>
    <link href="http://cctrip.github.io/2016/05/18/networkcomm/"/>
    <id>http://cctrip.github.io/2016/05/18/networkcomm/</id>
    <published>2016-05-17T16:36:31.000Z</published>
    <updated>2019-01-28T06:25:36.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="写在前面："><a href="#写在前面：" class="headerlink" title="写在前面："></a>写在前面：</h3><p>在计算机刚出现的时候，只能在本机进行一些运算处理，想将一台计算机中的数据转移到另一台计算机中，需要通过外部存储介质来传输，例如磁带、软盘。而网络技术的出现，使得计算机间可以通过一些传输介质(网线、光纤等)，实现快速的数据传输和信息交互。如今，网络已无处不在，那么，计算机之间究竟是如何通信的呢？下面会通过一些基础的网络知识来简单理解计算机之间的通信过程。</p><hr><h3 id="网络通信模型："><a href="#网络通信模型：" class="headerlink" title="网络通信模型："></a>网络通信模型：</h3><p>网络通信模型是一种概念模型和框架，旨在使各种计算机在世界范围内互连为网络。其中有OSI七层模型和TCP/IP四层模型，现在大部分网络通信都是以TCP/IP四层模型为基础的。它们的对应层次如下图：</p><p><img src="/2016/05/18/networkcomm/image/607348-20160312201154210-2019193861.jpg" alt=""></p><ul><li><p>OSI有七层：从上到下依次为应用层、表示层、会话层、传输层、网络层、数据链路层、物理层</p></li><li><p>TCP/IP有四层：从上到下依次为应用层、传输层、互连层(网络层)、网络接口层(链路层)。</p></li></ul><p>因为目前大部分TCP/IP模型，所以就以TCP/IP为例，我们来理解下数据间的通信，下图是两台计算机通信的数据的传输过程：</p><p><img src="/2016/05/18/networkcomm/image/607348-20160312202413054-848303498.png" alt=""></p><hr><h3 id="数据封装："><a href="#数据封装：" class="headerlink" title="数据封装："></a>数据封装：</h3><p>在详细了解TCP/IP每一层各自的作用前，先要理解数据封装的概念，数据在通过网络接口传送出去前，会经过层层封装，每层都会在前面的基础上添加自己的信息，在传输到对方计算机后，又会被层层进行解封装后得到最后的数据。其过程如下图所示：</p><p><img src="/2016/05/18/networkcomm/image/607348-20160312203516679-1695630421.gif" alt=""></p><hr><h3 id="TCP-IP参考模型："><a href="#TCP-IP参考模型：" class="headerlink" title="TCP/IP参考模型："></a>TCP/IP参考模型：</h3><p>TCP/IP参考模型是一个抽象的分层模型，这个模型中，所有的TCP/IP系列网络协议都被归类到4个抽象的”层”中。每一抽象层创建在低一层提供的服务上，并且为高一层提供服务。 完成一些特定的任务需要众多的协议协同工作，这些协议分布在参考模型的不同层中的，因此有时称它们为一个协议栈。</p><h5 id="应用层-Application-Layer-："><a href="#应用层-Application-Layer-：" class="headerlink" title="应用层(Application Layer)："></a>应用层(Application Layer)：</h5><ul><li>该层包括所有和应用程序协同工作，利用基础网络交换应用程序专用的数据的协议。 应用层是大多数普通与网络相关的程序为了通过网络与其他程序通信所使用的层。这个层的处理过程是应用特有的；数据从网络相关的程序以这种应用内部使用的格式进行传送，然后被编码成标准协议的格式。</li><li>常见的应用层协议有HTTP、FTP、DNS、SNMP(基于UDP)</li></ul><h5 id="传输层-Transport-Layer-："><a href="#传输层-Transport-Layer-：" class="headerlink" title="传输层(Transport Layer)："></a>传输层(Transport Layer)：</h5><ul><li>主要为两台主机上的应用程序提供端到端的通信，包括TCP协议（传输控制协议）和UDP（用户数据报协议）。<br>端口号由此层提供，且在一台计算机中具有唯一性。</li><li>UDP为应用层提供一种非常简单的服务。它只是把称作数据报的分组从一台主机发送到另一台主机，但并不保证该数据报能到达另一端。任何必需的可靠性必须由应用层来提供。</li><li>TCP为两台主机提供高可靠性的数据通信。它所做的工作包括把应用程序交给它的数据分成合适的小块交给下面的网络层，确认接收到的分组，设置发送最后确认分组的超时时钟等,由于运输层提供了高可靠性的端到端的通信，因此应用层可以忽略所有这些细节。</li><li>因为TCP是一种面向连接的协议，所以两个在使用TCP的应用在彼此交换数据前必须先建立一个TCP连接，也就是有名的TCP三次握手，如下图所示：</li></ul><p><img src="/2016/05/18/networkcomm/image/607348-20160312211241132-1517700594.png" alt=""></p><p>建立连接协议过程：（TCP三次握手协议）</p><ul><li>客户端发送一个SYN段指明客户打算连接的服务器的端口，以及初始序号（ISN）。</li><li>服务器发回包含服务器的初始序号的SYN报文段作为应答。同时，将确认序号设置为客户的ISN加1以对客户的SYN报文段进行确认。一个SYN占用一个序号。</li><li>客户将确认序号设置为服务器的ISN加1以对服务器的SYN报文段进行确认。</li></ul><h4 id="网络层-Internet-Layer-："><a href="#网络层-Internet-Layer-：" class="headerlink" title="网络层(Internet Layer)："></a>网络层(Internet Layer)：</h4><ul><li><p>处理分组在网络中的活动。网络层协议包括IP协议（网际协议），ICPM协议（Internet互联网控制报文协议），以及IGMP协议（Internet组管理协议），其中的IP协议身是TCP/IP协议簇中最为核心的协议。IP提供的是不可靠、无连接的数据包传送服务。</p></li><li><p>IP地址：</p></li><li><ul><li>讲到IP协议就应该讲讲IP地址，IP地址是分配给网络上使用IP协议的设备的数字标签，有IPv4和IPv6两大类，我们目前使用的大部分还是IPv4的地址，以下简称IP地址，IP地址由32位二进制数组成，为便于使用，常以XXX.XXX.XXX.XXX形式表示。IP地址由两个字段组成：网络号(net-id)和主机号(host-id)，为方便IP地址管理，IP地址被分为五类，如下图：</li></ul></li></ul><p><img src="/2016/05/18/networkcomm/image/607348-20160312213647569-286300397.gif" alt=""></p><ul><li><ul><li>其中A、B、C类地址为单播（unicast）地址；D类地址为组播（multicast）地址；E类地址为保留地址，以备将来的特殊用途。目前大量使用中的IP地址属于A、B、C三类地址。</li></ul></li><li><ul><li><ul><li>A类地址范围：0.0.0.0～127.255.255.255</li></ul></li></ul></li><li><ul><li><ul><li>B类地址范围：128.0.0.0～191.255.255.255</li></ul></li></ul></li><li><ul><li><ul><li>C类地址范围：192.0.0.0～223.255.255.255</li></ul></li></ul></li><li><ul><li><ul><li>私网地址范围：10.0.0.0～10.255.255.255 ，172.16.0.0～172.31.255.255 ，192.168.0.0～192.168.255.255，私网地址只能在本地局域网中使用，不在公网中使用。</li></ul></li></ul></li><li><p>子网和掩码：</p></li><li><ul><li>传统的IP地址分配方式，对IP地址的浪费非常严重。为了充分利用已有的IP地址，人们提出了掩码（mask）和子网（subnet）的概念。</li></ul></li><li><ul><li>掩码是一个与IP地址对应的32位数字，这些数字中一些为1，另外一些为0。原则上这些1和0可以任意组合，不过一般在设计掩码时，网络号码和子网号码的比特值为1，主机号码的比特值为0。掩码可以把IP地址分为两个部分：子网地址和主机地址。IP地址与掩码中为1的位对应的部分为子网地址，其他的位对应的部分则是主机地址。当不进行子网划分时，子网掩码即为默认值，此时子网掩码中“1”的长度就是网络号码的长度。即A类地址对应的掩码默认值为255.0.0.0；B类地址的掩码默认值为255.255.0.0；C类地址掩码的默认值为255.255.255.0。</li></ul></li><li><p>IP路由选择：</p></li><li><ul><li>概念：若目的主机与源主机在同一共享网络内，IP数据报直接送达目的主机，否则，主机把数据报发往默认的路由器上，由路由器进行数据报转发。</li></ul></li></ul><h4 id="链路层-Link-Layer-："><a href="#链路层-Link-Layer-：" class="headerlink" title="链路层(Link Layer)："></a>链路层(Link Layer)：</h4><ul><li>通常包括设备驱动程序和网络接口卡。处理与传输媒介的物理接口细节。主要协议有：ARP协议和RARP协议</li><li><p>MAC地址 ：数据链路层具有自己的寻址机制(48bit地址)，当一台主机把以太网数据帧发送到位于同一局域网上得另一台主机时，是根据48bit的以太网地址来确定目的接口的。</p></li><li><p>而ARP和RARP协议是为IP地址和MAC地址提供映射的：</p></li></ul><p><img src="/2016/05/18/networkcomm/image/607348-20160312214932366-1742109445.png" alt=""></p><hr><h4 id="使用："><a href="#使用：" class="headerlink" title="使用："></a>使用：</h4><ul><li><p>我们在判断两台主机应用之间的网络是否正常，通常是判断到对方IP和端口是否能通。</p></li><li><p>常用网络判断命令：</p></li><li><p>Windows：</p></li><li><ul><li><code>ping $IP：最常用的判断网络是否可达的命令。</code></li></ul></li></ul><p><img src="/2016/05/18/networkcomm/image/607348-20160312220145210-443719950.png" alt=""></p><ul><li><ul><li><code>tracert $IP：跟踪路由，即打印出本机到到目的IP，所经过路由。</code></li></ul></li></ul><p><img src="/2016/05/18/networkcomm/image/607348-20160312220158054-2124916124.png" alt=""></p><ul><li><ul><li><code>telnet $IP $port：可以测试某个IP和应用端口是否能通。</code></li></ul></li><li><ul><li><code>netstat：查看本机监听和建立连接的端口。</code></li></ul></li></ul><p><img src="/2016/05/18/networkcomm/image/607348-20160312220227866-1298265423.png" alt=""></p><ul><li><p>Linux：</p></li><li><ul><li><code>ping $IP：最常用的判断网络是否可达的命令</code></li></ul></li><li><ul><li><code>traceroute $IP：跟踪路由，即打印出本机到到目的IP，所经过路由。</code></li></ul></li><li><ul><li><code>或者使用mtr -ni 0.1 $IP，可以实现以上两个共同的效果</code></li></ul></li></ul><p><img src="/2016/05/18/networkcomm/image/607348-20160312221617569-1834112731.png" alt=""></p><ul><li><ul><li><code>nc -vz $IP $PORT：测试到目的IP的应用端口是否能通。</code></li></ul></li></ul><p><img src="/2016/05/18/networkcomm/image/607348-20160312221825819-331058027.png" alt=""></p><ul><li><ul><li><code>netstat -tupln：可以查看本机目前监听的端口</code></li></ul></li></ul><p><img src="/2016/05/18/networkcomm/image/607348-20160312221946585-1872997601.png" alt=""></p><hr><h4 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h4><p><a href="https://en.wikipedia.org/wiki/Internet_protocol_suite" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Internet_protocol_suite</a></p><p><a href="">《TCP/IP详解卷1:协议》</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;写在前面：&quot;&gt;&lt;a href=&quot;#写在前面：&quot; class=&quot;headerlink&quot; title=&quot;写在前面：&quot;&gt;&lt;/a&gt;写在前面：&lt;/h3&gt;&lt;p&gt;在计算机刚出现的时候，只能在本机进行一些运算处理，想将一台计算机中的数据转移到另一台计算机中，需要通过外部存储介质来
      
    
    </summary>
    
      <category term="technology" scheme="http://cctrip.github.io/categories/technology/"/>
    
    
      <category term="network" scheme="http://cctrip.github.io/tags/network/"/>
    
  </entry>
  
</feed>
