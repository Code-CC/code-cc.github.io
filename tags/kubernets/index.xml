<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>kubernets - Tag - CC&#39;s Trip</title>
        <link>https://cctrip.github.io/tags/kubernets/</link>
        <description>kubernets - Tag - CC&#39;s Trip</description>
        <generator>Hugo -- gohugo.io</generator><language>en</language><copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright><lastBuildDate>Mon, 09 Nov 2020 17:55:28 &#43;0800</lastBuildDate><atom:link href="https://cctrip.github.io/tags/kubernets/" rel="self" type="application/rss+xml" /><item>
    <title>深入理解LVS</title>
    <link>https://cctrip.github.io/deep_lvs/</link>
    <pubDate>Mon, 09 Nov 2020 17:55:28 &#43;0800</pubDate>
    <author>Author</author>
    <guid>https://cctrip.github.io/deep_lvs/</guid>
    <description><![CDATA[1. 介绍 接上一篇深入理解iptables，kubernetes service技术还用到ipvs技术，讲到ipvs，那就得说说LVS了，这篇我们来了解下LVS具体的实现机制。
 2. IPVS  IPVS（IP虚拟服务器）实现传输层负载均衡，通常称为第4层LAN交换。
 负载均衡器的概念可以看这篇文章，或者翻译版本。
大多数情况下，负载均衡器和代理这两个术语会被混用在一起，所谓的代理，简单来说，就是接收客户端的数据包再转发到对应的后端服务器上。
ipvs就在这样的软件，它依赖netfilter的功能来实现数据包的转发，我们还是先拉源码定义来看下。
ip_vs_core.c
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47  static const struct nf_hook_ops ip_vs_ops4[] = { /* After packet filtering, change source only for VS/NAT */ { .]]></description>
</item><item>
    <title>深入理解iptables</title>
    <link>https://cctrip.github.io/deep_iptables/</link>
    <pubDate>Sat, 07 Nov 2020 17:55:28 &#43;0800</pubDate>
    <author>Author</author>
    <guid>https://cctrip.github.io/deep_iptables/</guid>
    <description><![CDATA[1. 介绍 最近在刚好在看Kubernetes的service相关内容，里面用到了iptables和ipvs技术，好久没看iptables了，快忘记了，刚好复习重新记忆一下。
讲iptables和ipvs，有个东西就一定得清楚，那就是netfilter
 2. netfilter  netfilter是一个数据包处理框架。
 netfilter具备以下几个功能：
 数据包过滤 网络地址(端口)转换 数据包日志记录 用户空间数据包排队 其他数据包处理功能  2.1 netfilter架构 netfilter 提供了 5 个 hook 点。包经过协议栈时会触发内核模块注册在这里的处理函数 。触发哪个 hook 取决于包的方向（是发送还是接收）、包的目的地址、以及包在上一个 hook 点是被丢弃还是拒绝等等。
下面几个 hook 是内核协议栈中已经定义好的：
 NF_IP_PRE_ROUTING: 接收到的包进入协议栈后立即触发此 hook，在进行任何路由判断 （将包发往哪里）之前 NF_IP_LOCAL_IN: 接收到的包经过路由判断，如果目的是本机，将触发此 hook NF_IP_FORWARD: 接收到的包经过路由判断，如果目的是其他机器，将触发此 hook NF_IP_LOCAL_OUT: 本机产生的准备发送的包，在进入协议栈后立即触发此 hook NF_IP_POST_ROUTING: 本机产生的准备发送的包或者转发的包，在经过路由判断之后， 将触发此 hook  注册处理函数时必须提供优先级，以便 hook 触发时能按照 优先级高低调用处理函数。这使得多个模块（或者同一内核模块的多个实例）可以在同一 hook 点注册，并且有确定的处理顺序。内核模块会依次被调用，每次返回一个结果给 netfilter 框架，提示该对这个包做以下几个操作之一：
 NF_ACCEPT: 继续正常遍历 NF_DROP: 丢弃数据包，不再进行遍历 NF_STOLEN: 该模块接收了该包，不再进行遍历 NF_QUEUE: 将数据包排队（通常用于用户空间处理） NF_REPEAT: 再次调用此hook   3.]]></description>
</item></channel>
</rss>
