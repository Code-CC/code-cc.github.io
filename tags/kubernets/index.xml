<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>kubernets - Tag - CC&#39;s Trip</title>
        <link>https://cctrip.github.io/tags/kubernets/</link>
        <description>kubernets - Tag - CC&#39;s Trip</description>
        <generator>Hugo -- gohugo.io</generator><language>en</language><copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright><lastBuildDate>Sat, 07 Nov 2020 17:55:28 &#43;0800</lastBuildDate><atom:link href="https://cctrip.github.io/tags/kubernets/" rel="self" type="application/rss+xml" /><item>
    <title>深入理解iptables</title>
    <link>https://cctrip.github.io/deep_iptables/</link>
    <pubDate>Sat, 07 Nov 2020 17:55:28 &#43;0800</pubDate>
    <author>Author</author>
    <guid>https://cctrip.github.io/deep_iptables/</guid>
    <description><![CDATA[1. 介绍 最近在刚好在看Kubernetes的service相关内容，里面用到了iptables和ipvs技术，好久没看iptables了，快忘记了，刚好复习重新记忆一下。
讲iptables，有个东西就一定得清楚，那就是netfilter
 2. netfilter  netfilter是一个数据包处理框架。
 netfilter具备以下几个功能：
 数据包过滤 网络地址(端口)转换 数据包日志记录 用户空间数据包排队 其他数据包处理功能  2.1 netfilter架构 netfilter 提供了 5 个 hook 点。包经过协议栈时会触发内核模块注册在这里的处理函数 。触发哪个 hook 取决于包的方向（是发送还是接收）、包的目的地址、以及包在上一个 hook 点是被丢弃还是拒绝等等。
下面几个 hook 是内核协议栈中已经定义好的：
 NF_IP_PRE_ROUTING: 接收到的包进入协议栈后立即触发此 hook，在进行任何路由判断 （将包发往哪里）之前 NF_IP_LOCAL_IN: 接收到的包经过路由判断，如果目的是本机，将触发此 hook NF_IP_FORWARD: 接收到的包经过路由判断，如果目的是其他机器，将触发此 hook NF_IP_LOCAL_OUT: 本机产生的准备发送的包，在进入协议栈后立即触发此 hook NF_IP_POST_ROUTING: 本机产生的准备发送的包或者转发的包，在经过路由判断之后， 将触发此 hook  注册处理函数时必须提供优先级，以便 hook 触发时能按照 优先级高低调用处理函数。这使得多个模块（或者同一内核模块的多个实例）可以在同一 hook 点注册，并且有确定的处理顺序。内核模块会依次被调用，每次返回一个结果给 netfilter 框架，提示该对这个包做以下几个操作之一：
 NF_ACCEPT: 继续正常遍历 NF_DROP: 丢弃数据包，不再进行遍历 NF_STOLEN: 该模块接收了该包，不再进行遍历 NF_QUEUE: 将数据包排队（通常用于用户空间处理） NF_REPEAT: 再次调用此hook   3.]]></description>
</item></channel>
</rss>
